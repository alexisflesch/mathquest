"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.gameEndedPayloadSchema = exports.testConnectionPayloadSchema = exports.joinRoomPayloadSchema = exports.connectedCountPayloadSchema = exports.sharedAnswerPayloadSchema = exports.sharedJoinPayloadSchema = exports.requestParticipantsPayloadSchema = exports.startGamePayloadSchema = exports.getParticipantsPayloadSchema = exports.leaveLobbyPayloadSchema = exports.joinLobbyPayloadSchema = exports.leaveProjectorPayloadSchema = exports.joinProjectorPayloadSchema = exports.startTournamentPayloadSchema = exports.pauseTimerPayloadSchema = exports.startTimerPayloadSchema = exports.serverToClientEventsSchema = exports.answerFeedbackPayloadSchema = exports.answerReceivedPayloadSchema = exports.gameStateUpdatePayloadSchema = exports.feedbackPayloadSchema = exports.correctAnswersPayloadSchema = exports.requestNextQuestionPayloadSchema = exports.gameJoinedPayloadSchema = exports.socketDataSchema = exports.interServerEventsSchema = exports.clientToServerEventsSchema = exports.leaderboardEntryDataSchema = exports.questionDataSchema = exports.questionDataForTeacherSchema = exports.questionDataForStudentSchema = exports.notificationPayloadSchema = exports.playerJoinedGamePayloadSchema = exports.gameAlreadyPlayedPayloadSchema = exports.errorPayloadSchema = exports.gameAnswerPayloadSchema = exports.participantDataSchema = exports.leaveGamePayloadSchema = exports.joinGamePayloadSchema = exports.endGamePayloadSchema = exports.lockAnswersPayloadSchema = exports.timerActionPayloadSchema = exports.joinDashboardPayloadSchema = exports.setQuestionPayloadSchema = exports.participationTypeSchema = exports.participantStatusSchema = exports.gameTimerUpdatePayloadSchema = exports.dashboardTimerUpdatedPayloadSchema = exports.gameTimerStateSchema = exports.timerUpdatePayloadSchema = void 0;
exports.revealLeaderboardPayloadSchema = exports.connectionEstablishedPayloadSchema = void 0;
// Generated by ts-to-zod
const zod_1 = require("zod");
// Timer update payload schema
exports.timerUpdatePayloadSchema = zod_1.z.object({
    timeLeftMs: zod_1.z.number().int().nonnegative().nullable(),
    running: zod_1.z.boolean(),
    durationMs: zod_1.z.number().int().positive().optional(),
    serverTime: zod_1.z.number().int().nonnegative({ message: "serverTime must be a non-negative integer (ms since epoch, UTC)." }),
});
// Canonical Zod schema for GameTimerState (MODERNIZED: only canonical fields)
exports.gameTimerStateSchema = zod_1.z.object({
    status: zod_1.z.enum(['run', 'pause', 'stop']),
    timerEndDateMs: zod_1.z.number(),
    questionUid: zod_1.z.string(),
});
// DashboardTimerUpdatedPayload (MODERNIZED)
exports.dashboardTimerUpdatedPayloadSchema = zod_1.z.object({
    timer: exports.gameTimerStateSchema,
    questionUid: zod_1.z.string(),
    questionIndex: zod_1.z.number(),
    totalQuestions: zod_1.z.number(),
    answersLocked: zod_1.z.boolean(),
    serverTime: zod_1.z.number().int().nonnegative({ message: "serverTime must be a non-negative integer (ms since epoch, UTC)." }),
});
// GameTimerUpdatePayload (MODERNIZED)
exports.gameTimerUpdatePayloadSchema = zod_1.z.object({
    timer: exports.gameTimerStateSchema,
    questionUid: zod_1.z.string(),
    questionIndex: zod_1.z.number(),
    totalQuestions: zod_1.z.number(),
    answersLocked: zod_1.z.boolean(),
    serverTime: zod_1.z.number().int().nonnegative({ message: "serverTime must be a non-negative integer (ms since epoch, UTC)." }),
});
// Participant status enum schema for unified join flow
exports.participantStatusSchema = zod_1.z.enum(['PENDING', 'ACTIVE', 'COMPLETED', 'LEFT'], {
    errorMap: () => ({ message: "Status must be one of: PENDING, ACTIVE, COMPLETED, LEFT" }),
});
// Participation type enum schema
exports.participationTypeSchema = zod_1.z.enum(['LIVE', 'DEFERRED'], {
    errorMap: () => ({ message: "Participation type must be one of: LIVE, DEFERRED" }),
});
// Teacher dashboard payload schemas
exports.setQuestionPayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
    questionUid: zod_1.z.string().min(1, { message: "Question UID cannot be empty." }),
    questionIndex: zod_1.z.number().int().nonnegative({ message: "Question index must be non-negative." }).optional(),
});
exports.joinDashboardPayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
});
exports.timerActionPayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
    action: zod_1.z.enum(['run', 'pause', 'stop', 'edit'], {
        errorMap: () => ({ message: "Action must be one of: run, pause, stop, edit" }),
    }),
    /**
     * Absolute timestamp (ms since epoch, UTC) when the timer is scheduled to end.
     * This is the canonical end date for the timer, used for backend/logic and precise signaling.
     * May be updated if the timer is changed during a quiz.
     */
    timerEndDateMs: zod_1.z.number().int().nonnegative({ message: "timerEndDateMs must be a non-negative integer (ms since epoch, UTC)." }).optional(),
    /**
     * Target time in milliseconds (duration or remaining time, NOT a date).
     * Used for UI, duration, or other timer logic. Distinct from timerEndDateMs.
     */
    targetTimeMs: zod_1.z.number().int().nonnegative({ message: "targetTimeMs must be a non-negative integer." }).optional(),
    questionUid: zod_1.z.string().min(1, { message: "Question UID cannot be empty." }),
    /**
     * For 'edit' action: the new duration in milliseconds (REQUIRED for 'edit')
     */
    durationMs: zod_1.z.number().int().nonnegative({ message: "durationMs must be a non-negative integer (ms)." }).optional(),
});
exports.lockAnswersPayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
    lock: zod_1.z.boolean({ errorMap: () => ({ message: "Lock must be a boolean value." }) }),
});
exports.endGamePayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
});
// UNIFIED JOIN FLOW SCHEMAS
exports.joinGamePayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
    userId: zod_1.z.string().min(1, { message: "Player ID cannot be empty." }),
    username: zod_1.z.string().min(1, { message: "Username cannot be empty." }),
    avatarEmoji: zod_1.z.string().optional(),
});
// Leave game payload schema for unified flow
exports.leaveGamePayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
    userId: zod_1.z.string().min(1, { message: "User ID cannot be empty." }),
});
// Participant data schema with status
exports.participantDataSchema = zod_1.z.object({
    id: zod_1.z.string().min(1, { message: "Participant ID cannot be empty." }),
    userId: zod_1.z.string().min(1, { message: "User ID cannot be empty." }),
    username: zod_1.z.string().min(1, { message: "Username cannot be empty." }),
    avatarEmoji: zod_1.z.string().optional(), // Allow optional as per interface
    score: zod_1.z.number().int().nonnegative({ message: "Score must be non-negative." }),
    status: exports.participantStatusSchema.optional(),
    online: zod_1.z.boolean().optional(),
    joinedAt: zod_1.z.union([zod_1.z.number(), zod_1.z.string()]).optional(),
    socketId: zod_1.z.string().optional(),
    attemptCount: zod_1.z.number().int().nonnegative().optional(),
});
exports.gameAnswerPayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
    userId: zod_1.z.string().min(1, { message: "Player ID cannot be empty." }),
    questionUid: zod_1.z.string().min(1, { message: "Question UID cannot be empty." }),
    answer: zod_1.z.union([
        zod_1.z.string(),
        zod_1.z.number(),
        zod_1.z.array(zod_1.z.string()),
        zod_1.z.array(zod_1.z.number())
    ]),
    timeSpent: zod_1.z.number().int({ message: "Time spent must be an integer." }).nonnegative({ message: "Time spent cannot be negative." }),
});
exports.errorPayloadSchema = zod_1.z.object({
    message: zod_1.z.string().min(1, { message: "Error message cannot be empty." }),
    code: zod_1.z.union([zod_1.z.string(), zod_1.z.number()]).optional(),
    details: zod_1.z.record(zod_1.z.any()).optional(),
});
exports.gameAlreadyPlayedPayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
});
exports.playerJoinedGamePayloadSchema = zod_1.z.object({
    participant: exports.participantDataSchema,
});
exports.notificationPayloadSchema = zod_1.z.object({
    message: zod_1.z.string().min(1, { message: "Notification message cannot be empty." }),
    defaultMode: zod_1.z.enum(['info', 'warning', 'error', 'success']),
});
// === CANONICAL SPLIT: Student vs. Teacher Question Payloads ===
// Student: never receives correctAnswers or explanation
exports.questionDataForStudentSchema = zod_1.z.object({
    uid: zod_1.z.string().min(1, { message: "Question UID cannot be empty." }),
    title: zod_1.z.string().min(1).optional(),
    text: zod_1.z.string().min(1, { message: "Question text cannot be empty." }),
    answerOptions: zod_1.z.array(zod_1.z.string().min(1)).min(1, { message: "At least one answer option is required." }),
    questionType: zod_1.z.string().min(1, { message: "Question type cannot be empty." }),
    timeLimit: zod_1.z.number().int({ message: "Time limit must be an integer." }).positive({ message: "Time limit must be positive." }),
    currentQuestionIndex: zod_1.z.number().int({ message: "Question index must be an integer." }).nonnegative({ message: "Question index cannot be negative." }).optional(),
    totalQuestions: zod_1.z.number().int({ message: "Total questions must be an integer." }).positive({ message: "Total questions must be positive." }).optional(),
});
// Teacher/Projection: includes correctAnswers and explanation
exports.questionDataForTeacherSchema = exports.questionDataForStudentSchema.extend({
    correctAnswers: zod_1.z.array(zod_1.z.boolean()),
    explanation: zod_1.z.string().optional(),
});
// For legacy/compatibility: REMOVE after migration
/** @deprecated Use questionDataForStudentSchema or questionDataForTeacherSchema */
exports.questionDataSchema = exports.questionDataForStudentSchema;
exports.leaderboardEntryDataSchema = zod_1.z.object({
    userId: zod_1.z.string().min(1, { message: "Player ID cannot be empty." }),
    username: zod_1.z.string().min(1, { message: "Username cannot be empty." }),
    avatarEmoji: zod_1.z.string().optional(),
    score: zod_1.z.number().int({ message: "Score must be an integer." }),
    rank: zod_1.z.number().int({ message: "Rank must be an integer." }).positive({ message: "Rank must be positive." }).optional(),
});
exports.clientToServerEventsSchema = zod_1.z.object({
    join_game: zod_1.z.function().args(exports.joinGamePayloadSchema).returns(zod_1.z.void()),
    game_answer: zod_1.z.function().args(exports.gameAnswerPayloadSchema).returns(zod_1.z.void()),
    request_participants: zod_1.z
        .function()
        .args(zod_1.z.object({
        accessCode: zod_1.z.string().min(1),
    }))
        .returns(zod_1.z.void()),
    teacher_set_question: zod_1.z
        .function()
        .args(zod_1.z.object({
        accessCode: zod_1.z.string().min(1),
        questionUid: zod_1.z.string().min(1),
        questionIndex: zod_1.z.number().int().nonnegative(),
    }))
        .returns(zod_1.z.void()),
    teacher_timer_action: zod_1.z
        .function()
        .args(exports.timerActionPayloadSchema)
        .returns(zod_1.z.void()),
    teacher_lock_answers: zod_1.z
        .function()
        .args(zod_1.z.object({
        accessCode: zod_1.z.string().min(1),
        lock: zod_1.z.boolean(),
    }))
        .returns(zod_1.z.void()),
    teacher_end_game: zod_1.z
        .function()
        .args(zod_1.z.object({
        accessCode: zod_1.z.string().min(1),
    }))
        .returns(zod_1.z.void()),
});
exports.interServerEventsSchema = zod_1.z.object({});
exports.socketDataSchema = zod_1.z.object({
    userId: zod_1.z.string().min(1).optional(),
    username: zod_1.z.string().min(1).optional(),
    role: zod_1.z.enum(['STUDENT', 'TEACHER', 'GUEST']).optional(),
    accessCode: zod_1.z.string().min(1).optional(),
    currentGameRoom: zod_1.z.string().min(1).optional(),
});
exports.gameJoinedPayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
    participant: exports.participantDataSchema,
    gameStatus: zod_1.z.enum(['pending', 'active', 'completed', 'archived']),
    differedAvailableFrom: zod_1.z.string().datetime({ message: "Invalid datetime string for differedAvailableFrom. Must be an ISO string." }).optional(),
    differedAvailableTo: zod_1.z.string().datetime({ message: "Invalid datetime string for differedAvailableTo. Must be an ISO string." }).optional(),
});
exports.requestNextQuestionPayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
    userId: zod_1.z.string().min(1, { message: "User ID cannot be empty." }),
    currentQuestionUid: zod_1.z.string().min(1, { message: "Current question UID cannot be empty." }),
});
// Canonical event payload schemas (for tournament-style events)
exports.correctAnswersPayloadSchema = zod_1.z.object({
    questionUid: zod_1.z.string().min(1, { message: "Question UID cannot be empty." }),
    correctAnswers: zod_1.z.array(zod_1.z.boolean()).optional(),
    /**
     * Map of questionUid to boolean indicating if correct answers have been shown (terminated)
     */
    terminatedQuestions: zod_1.z.record(zod_1.z.string(), zod_1.z.boolean()).optional(),
});
exports.feedbackPayloadSchema = zod_1.z.object({
    questionUid: zod_1.z.string().min(1, { message: "Question UID cannot be empty." }),
    feedbackRemaining: zod_1.z.number().int().nonnegative({ message: "Feedback remaining must be non-negative." }),
}).catchall(zod_1.z.any()); // Allow additional properties for flexibility
// Game state update payload schema
exports.gameStateUpdatePayloadSchema = zod_1.z.object({
    status: zod_1.z.enum(['waiting', 'active', 'paused', 'finished']).optional(),
    currentQuestion: exports.questionDataSchema.optional(),
    questionIndex: zod_1.z.number().int().nonnegative().optional(),
    totalQuestions: zod_1.z.number().int().positive().optional(),
    timer: zod_1.z.number().int().nonnegative().optional(),
    participants: zod_1.z.array(exports.participantDataSchema).optional(),
}).catchall(zod_1.z.any()); // Allow additional properties for flexibility
// Answer received payload schema
exports.answerReceivedPayloadSchema = zod_1.z.object({
    questionUid: zod_1.z.string().min(1, { message: "Question UID cannot be empty." }),
    timeSpent: zod_1.z.number().int().nonnegative({ message: "Time spent must be a non-negative integer." }),
    correct: zod_1.z.boolean().optional(),
    correctAnswers: zod_1.z.array(zod_1.z.boolean()).optional(),
    explanation: zod_1.z.string().optional(),
});
// Answer feedback payload schema
exports.answerFeedbackPayloadSchema = zod_1.z.object({
    status: zod_1.z.enum(['ok', 'error'], { message: "Status must be 'ok' or 'error'." }),
    questionUid: zod_1.z.string().min(1, { message: "Question UID cannot be empty." }).optional(),
    scoreAwarded: zod_1.z.number().int().nonnegative({ message: "Score awarded must be a non-negative integer." }).optional(),
    code: zod_1.z.string().optional(),
    message: zod_1.z.string().optional(),
    isCorrect: zod_1.z.boolean().optional(),
    correctAnswers: zod_1.z.array(zod_1.z.boolean()).optional(),
    explanation: zod_1.z.string().optional(),
}).catchall(zod_1.z.any()); // Allow additional properties for flexibility
exports.serverToClientEventsSchema = zod_1.z.object({
    connect: zod_1.z.function().args().returns(zod_1.z.void()),
    disconnect: zod_1.z.function().args(zod_1.z.string()).returns(zod_1.z.void()),
    connection_established: zod_1.z
        .function()
        .args(zod_1.z.object({
        socketId: zod_1.z.string().min(1),
        timestamp: zod_1.z.string().datetime(),
        user: exports.socketDataSchema.partial(),
    }))
        .returns(zod_1.z.void()),
    game_joined: zod_1.z.function().args(exports.gameJoinedPayloadSchema).returns(zod_1.z.void()),
    game_question: zod_1.z.function().args(exports.questionDataSchema).returns(zod_1.z.void()),
    answer_received: zod_1.z.function().args(exports.answerReceivedPayloadSchema).returns(zod_1.z.void()),
    leaderboard_update: zod_1.z
        .function()
        .args(zod_1.z.object({
        leaderboard: zod_1.z.array(exports.leaderboardEntryDataSchema),
    }))
        .returns(zod_1.z.void()),
    player_joined_game: zod_1.z
        .function()
        .args(exports.playerJoinedGamePayloadSchema)
        .returns(zod_1.z.void()),
    player_left_game: zod_1.z
        .function()
        .args(zod_1.z.object({
        userId: zod_1.z.string().min(1),
        socketId: zod_1.z.string().min(1),
    }))
        .returns(zod_1.z.void()),
    game_participants: zod_1.z
        .function()
        .args(zod_1.z.object({
        participants: zod_1.z.array(exports.participantDataSchema),
    }))
        .returns(zod_1.z.void()),
    game_state_update: zod_1.z.function().args(exports.gameStateUpdatePayloadSchema).returns(zod_1.z.void()),
    timer_update: zod_1.z
        .function()
        .args(exports.timerUpdatePayloadSchema)
        .returns(zod_1.z.void()),
    answers_locked: zod_1.z
        .function()
        .args(zod_1.z.object({
        locked: zod_1.z.boolean(),
    }))
        .returns(zod_1.z.void()),
    game_ended: zod_1.z
        .function()
        .args(zod_1.z.object({
        accessCode: zod_1.z.string().min(1),
    }))
        .returns(zod_1.z.void()),
    game_error: zod_1.z.function().args(exports.errorPayloadSchema).returns(zod_1.z.void()),
    game_already_played: zod_1.z
        .function()
        .args(exports.gameAlreadyPlayedPayloadSchema)
        .returns(zod_1.z.void()),
    notification: zod_1.z.function().args(exports.notificationPayloadSchema).returns(zod_1.z.void()),
    game_control_question_set: zod_1.z
        .function()
        .args(zod_1.z.object({
        questionIndex: zod_1.z.number().int().nonnegative(),
        timer: zod_1.z.object({
            startedAt: zod_1.z.number(),
            duration: zod_1.z.number(),
            isPaused: zod_1.z.boolean(),
            pausedAt: zod_1.z.number().optional(),
            timeRemaining: zod_1.z.number().optional()
        })
    }))
        .returns(zod_1.z.void()),
    game_control_question_ended: zod_1.z
        .function()
        .args(zod_1.z.object({
        questionUid: zod_1.z.string(),
        timer: zod_1.z.object({
            startedAt: zod_1.z.number(),
            duration: zod_1.z.number(),
            isPaused: zod_1.z.boolean(),
            pausedAt: zod_1.z.number().optional(),
            timeRemaining: zod_1.z.number().optional()
        })
    }))
        .returns(zod_1.z.void()),
    question_ended: zod_1.z
        .function()
        .args(zod_1.z.object({
        questionUid: zod_1.z.string(),
        showLeaderboard: zod_1.z.boolean().optional(),
        leaderboard: zod_1.z.array(zod_1.z.object({
            userId: zod_1.z.string(),
            username: zod_1.z.string(),
            avatarEmoji: zod_1.z.string().optional(),
            score: zod_1.z.number()
        })).optional()
    }))
        .returns(zod_1.z.void()),
    // Teacher dashboard socket event schemas
    set_question: zod_1.z.function().args(exports.setQuestionPayloadSchema).returns(zod_1.z.void()),
    join_dashboard: zod_1.z.function().args(exports.joinDashboardPayloadSchema).returns(zod_1.z.void()),
    timer_action: zod_1.z.function().args(exports.timerActionPayloadSchema).returns(zod_1.z.void()),
    lock_answers: zod_1.z.function().args(exports.lockAnswersPayloadSchema).returns(zod_1.z.void()),
    end_game: zod_1.z.function().args(exports.endGamePayloadSchema).returns(zod_1.z.void()),
    // Canonical tournament/practice events
    correct_answers: zod_1.z.function().args(exports.correctAnswersPayloadSchema).returns(zod_1.z.void()),
    feedback: zod_1.z.function().args(exports.feedbackPayloadSchema).returns(zod_1.z.void()),
});
// Additional teacher control schemas
exports.startTimerPayloadSchema = zod_1.z.object({
    gameId: zod_1.z.string().min(1, { message: "Game ID cannot be empty." }).optional(),
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }).optional(),
    durationMs: zod_1.z.number().int().positive({ message: "durationMs must be a positive integer (ms)." }),
}).refine(data => data.gameId || data.accessCode, {
    message: "Either gameId or accessCode must be provided.",
});
exports.pauseTimerPayloadSchema = zod_1.z.object({
    gameId: zod_1.z.string().min(1, { message: "Game ID cannot be empty." }).optional(),
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }).optional(),
}).refine(data => data.gameId || data.accessCode, {
    message: "Either gameId or accessCode must be provided.",
});
// Tournament schemas
exports.startTournamentPayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
});
// Projector schemas
exports.joinProjectorPayloadSchema = zod_1.z.object({
    gameId: zod_1.z.string().min(1, { message: "Game ID cannot be empty." }),
});
exports.leaveProjectorPayloadSchema = zod_1.z.object({
    gameId: zod_1.z.string().min(1, { message: "Game ID cannot be empty." }),
});
// DEPRECATED LOBBY SCHEMAS - Use unified join flow instead
// These will be removed after migration to unified join flow
/**
 * @deprecated Use joinGamePayloadSchema instead
 */
exports.joinLobbyPayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
    userId: zod_1.z.string().min(1, { message: "User ID cannot be empty." }),
    username: zod_1.z.string().min(1, { message: "Username cannot be empty." }),
    avatarEmoji: zod_1.z.string().optional(),
});
/**
 * @deprecated Use leaveGamePayloadSchema instead
 */
exports.leaveLobbyPayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
    userId: zod_1.z.string().min(1, { message: "User ID cannot be empty." }).optional(),
});
/**
 * @deprecated Use joinGamePayloadSchema instead
 */
exports.getParticipantsPayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
});
// Game start schema
exports.startGamePayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
    userId: zod_1.z.string().min(1, { message: "User ID cannot be empty." }),
});
exports.requestParticipantsPayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
});
// Shared live handler schemas
exports.sharedJoinPayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
    userId: zod_1.z.string().min(1, { message: "User ID cannot be empty." }),
    username: zod_1.z.string().min(1, { message: "Username cannot be empty." }),
    avatarEmoji: zod_1.z.string().optional(),
    playMode: zod_1.z.enum(['quiz', 'tournament', 'practice']).optional(),
});
exports.sharedAnswerPayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
    userId: zod_1.z.string().min(1, { message: "User ID cannot be empty." }),
    questionUid: zod_1.z.string().min(1, { message: "Question UID cannot be empty." }),
    answer: zod_1.z.union([
        zod_1.z.string(),
        zod_1.z.number(),
        zod_1.z.array(zod_1.z.string()),
        zod_1.z.array(zod_1.z.number())
    ]),
    timeSpent: zod_1.z.number().int({ message: "Time spent must be an integer." }).nonnegative({ message: "Time spent cannot be negative." }),
    playMode: zod_1.z.enum(['quiz', 'tournament', 'practice']).optional(),
});
// Dashboard payload schemas
exports.connectedCountPayloadSchema = zod_1.z.object({
    count: zod_1.z.number().int().nonnegative({ message: "Count must be a non-negative integer." }),
});
// Test-specific schemas for unit tests
exports.joinRoomPayloadSchema = zod_1.z.object({
    roomName: zod_1.z.string().min(1, { message: "Room name cannot be empty." }),
});
exports.testConnectionPayloadSchema = zod_1.z.object({
// No payload for connection event, but we can validate the socket metadata
});
// Game ended payload schema
exports.gameEndedPayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
    endedAt: zod_1.z.string().datetime({ message: "Invalid datetime string for endedAt. Must be an ISO string." }).optional(),
    score: zod_1.z.number().int().nonnegative({ message: "Score must be a non-negative integer." }).optional(),
    totalQuestions: zod_1.z.number().int().nonnegative({ message: "Total questions must be a non-negative integer." }).optional(),
    correct: zod_1.z.number().int().nonnegative({ message: "Correct answers count must be a non-negative integer." }).optional(),
    total: zod_1.z.number().int().nonnegative({ message: "Total answers count must be a non-negative integer." }).optional(),
});
// Connection established payload schema
exports.connectionEstablishedPayloadSchema = zod_1.z.object({
    socketId: zod_1.z.string().min(1, { message: "Socket ID cannot be empty." }),
    timestamp: zod_1.z.string().datetime({ message: "Invalid datetime string for timestamp. Must be an ISO string." }),
    user: zod_1.z.object({
        userId: zod_1.z.string().optional(),
        username: zod_1.z.string().optional(),
        role: zod_1.z.enum(['STUDENT', 'TEACHER', 'GUEST']).optional(),
        accessCode: zod_1.z.string().optional(),
        currentGameRoom: zod_1.z.string().optional(),
        practiceSessionId: zod_1.z.string().optional(),
        practiceUserId: zod_1.z.string().optional(),
    }).partial(),
});
exports.revealLeaderboardPayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." })
});
