"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.questionUpdateSchema = exports.questionCreationSchema = exports.questionSchema = void 0;
// Generated by ts-to-zod
const zod_1 = require("zod");
// Base question schema with common fields
const baseQuestionSchema = zod_1.z.object({
    uid: zod_1.z.string().optional(),
    title: zod_1.z.string().nullable().optional(), // Allow null from database
    text: zod_1.z.string({ required_error: "Question text is required" }),
    questionType: zod_1.z.string({ required_error: "Question type is required" }),
    discipline: zod_1.z.string({ required_error: "Discipline is required" }),
    themes: zod_1.z.array(zod_1.z.string()).optional(),
    difficulty: zod_1.z.number().optional(),
    gradeLevel: zod_1.z.string().optional(),
    author: zod_1.z.string().nullable().optional(), // Allow null from database
    explanation: zod_1.z.string().nullable().optional(), // Allow null from database
    tags: zod_1.z.array(zod_1.z.string()).optional(),
    excludedFrom: zod_1.z.array(zod_1.z.string()).optional(),
    durationMs: zod_1.z.number({ required_error: "durationMs is required" })
});
// Multiple choice question data schema
const multipleChoiceQuestionDataSchema = zod_1.z.object({
    answerOptions: zod_1.z.array(zod_1.z.string(), { required_error: "Answer options are required" }),
    correctAnswers: zod_1.z.array(zod_1.z.boolean(), { required_error: "Correct answers are required" })
});
// Numeric question data schema
const numericQuestionDataSchema = zod_1.z.object({
    correctAnswer: zod_1.z.number({ required_error: "Correct answer is required" }),
    tolerance: zod_1.z.number().nullable().optional(), // Allow null from database
    unit: zod_1.z.string().nullable().optional() // Allow null values from database
});
// Raw polymorphic question schema (without refinement)
const rawQuestionSchema = baseQuestionSchema.extend({
    // Polymorphic relations - only one should be populated
    multipleChoiceQuestion: multipleChoiceQuestionDataSchema.optional(),
    numericQuestion: numericQuestionDataSchema.optional(),
    // Legacy fields for backward compatibility (optional)
    answerOptions: zod_1.z.array(zod_1.z.string()).optional(),
    correctAnswers: zod_1.z.array(zod_1.z.boolean()).optional()
});
// Polymorphic question schema with validation
exports.questionSchema = rawQuestionSchema.refine((data) => {
    // Ensure at least one question type data is present
    if (data.questionType === 'multipleChoice') {
        return !!(data.multipleChoiceQuestion || (data.answerOptions && data.correctAnswers));
    }
    if (data.questionType === 'numeric') {
        return !!data.numericQuestion;
    }
    return true;
}, {
    message: "Question must have appropriate type-specific data"
});
// Schema for creating a question, essentially the same as rawQuestionSchema but without uid if it's auto-generated
exports.questionCreationSchema = rawQuestionSchema.omit({ uid: true });
// Schema for partial updates (without refinement to allow .partial() method)
exports.questionUpdateSchema = rawQuestionSchema.partial();
