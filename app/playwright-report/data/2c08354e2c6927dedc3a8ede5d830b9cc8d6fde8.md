# Test info

- Name: mobile multiple-choice live: tap answer and collect overlay diagnostics
- Location: /home/aflesch/mathquest/app/tests/e2e/mobile-mc-live-freeze-repro.spec.ts:551:5

# Error details

```
Error: Student should receive a new QUESTION UPDATE after teacher switches question

expect(received).toBeTruthy()

Received: false
    at /home/aflesch/mathquest/app/tests/e2e/mobile-mc-live-freeze-repro.spec.ts:770:115
```

# Test source

```ts
  670 |                 const timer = document.querySelector('[class*="Timer"]') as HTMLElement | null;
  671 |                 const anyFixed = Array.from(document.querySelectorAll<HTMLElement>('*')).filter(e => getComputedStyle(e).position === 'fixed').length;
  672 |                 const ovStyles = overlay ? getComputedStyle(overlay) : null;
  673 |                 const rect = document.querySelector('.tqcard-answer')?.getBoundingClientRect();
  674 |                 const midX = rect ? Math.floor(rect.left + rect.width / 2) : 50;
  675 |                 const midY = rect ? Math.floor(rect.top + rect.height / 2) : 200;
  676 |                 const elAtPoint = document.elementFromPoint(midX, midY);
  677 |                 const ancestry: string[] = [];
  678 |                 let n: Element | null = elAtPoint;
  679 |                 while (n && ancestry.length < 6) { ancestry.push(n instanceof HTMLElement ? `${n.tagName}.${n.className}` : n.tagName); n = n.parentElement; }
  680 |                 return {
  681 |                     overlayPresent: !!overlay,
  682 |                     overlayPointerEvents: ovStyles?.pointerEvents,
  683 |                     overlayZ: ovStyles?.zIndex,
  684 |                     cardPresent: !!card,
  685 |                     timerPresent: !!timer,
  686 |                     anyFixed,
  687 |                     elementAtPoint: elAtPoint ? (elAtPoint as HTMLElement).className : null,
  688 |                     ancestry,
  689 |                 };
  690 |             });
  691 |             log('[MC-MOBILE-FREEZE-DIAG]', diag);
  692 |         }
  693 |
  694 |         // Post stop/resume, ensure buttons are still clickable (not frozen under overlays)
  695 |         const containerPointerEvents = await studentPage.evaluate(() => getComputedStyle(document.querySelector('.tqcard-content') as HTMLElement).pointerEvents);
  696 |         log('[POST-RESUME] pointer-events on .tqcard-content', { containerPointerEvents });
  697 |         const clickableCheck = await firstAnswer.isEnabled();
  698 |         log('[POST-RESUME] first answer isEnabled()', { clickableCheck });
  699 |
  700 |         // Optional: if feedback overlay appears, wait for it to disappear, then try tapping again
  701 |         const overlay = studentPage.locator('[data-testid="feedback-overlay"]');
  702 |         if (await overlay.count()) {
  703 |             log('Feedback overlay detected; waiting briefly...');
  704 |             await overlay.waitFor({ state: 'visible', timeout: 5000 }).catch(() => { });
  705 |             await studentPage.waitForTimeout(1000);
  706 |             await overlay.waitFor({ state: 'hidden', timeout: 10000 }).catch(() => { });
  707 |             log('Overlay hidden; attempting another tap');
  708 |             const before2 = await firstAnswer.getAttribute('class');
  709 |             await firstAnswer.click({ timeout: 5000 }).catch(() => { });
  710 |             const after2 = await firstAnswer.getAttribute('class');
  711 |             if (before2 === after2) {
  712 |                 const diag2 = await studentPage.evaluate(() => {
  713 |                     const overlay = document.querySelector('.feedback-overlay') as HTMLElement | null;
  714 |                     const ovStyles = overlay ? getComputedStyle(overlay) : null;
  715 |                     const rect = document.querySelector('.tqcard-answer')?.getBoundingClientRect();
  716 |                     const midX = rect ? Math.floor(rect.left + rect.width / 2) : 50;
  717 |                     const midY = rect ? Math.floor(rect.top + rect.height / 2) : 200;
  718 |                     const elAtPoint = document.elementFromPoint(midX, midY);
  719 |                     return {
  720 |                         overlayVisible: !!overlay,
  721 |                         overlayPointerEvents: ovStyles?.pointerEvents,
  722 |                         elementAtPoint: elAtPoint ? (elAtPoint as HTMLElement).className : null,
  723 |                     };
  724 |                 });
  725 |                 log('[MC-MOBILE-POST-OVERLAY-DIAG]', diag2);
  726 |             }
  727 |         }
  728 |
  729 |         expect(firstAnswer).toBeTruthy();
  730 |
  731 |         // Collect crash logs and long tasks from student
  732 |         const collected = await studentDiag.getCollected();
  733 |         log('[student-errors]', collected);
  734 |         const infoLogs = await studentDiag.getInfoEvents();
  735 |         log('[student-info-socket-logs-summary]', {
  736 |             total: infoLogs.length,
  737 |             last3: infoLogs.slice(-3).map(l => l.text.substring(0, 200))
  738 |         });
  739 |         // TDD assertion: no hydration mismatch errors should be present
  740 |         const studentHasHydrationError = collected.errors.some(e => e.toLowerCase().includes('hydration failed')) ||
  741 |             collected.windowErrors.errors.some((e: any) => String(e.message || '').toLowerCase().includes('hydration failed'));
  742 |         expect(studentHasHydrationError, 'No hydration mismatch should occur on student flow').toBeFalsy();
  743 |         const socketEvents = await studentSocketCap.getEvents();
  744 |         log('[student-socket-events-summary]', {
  745 |             total: socketEvents.length,
  746 |             last5: socketEvents.slice(-5).map((e: any) => e.event)
  747 |         });
  748 |         const longTasks = await studentPage.evaluate(() => {
  749 |             try {
  750 |                 const entries = (performance as any).getEntriesByType?.('longtask') || [];
  751 |                 return entries.map((e: any) => ({ duration: e.duration, name: e.name, startTime: e.startTime })).slice(0, 10);
  752 |             } catch { return []; }
  753 |         });
  754 |         log('[student-longtasks-top10]', longTasks);
  755 |
  756 |         // --- Question switch stress (iPhone): switch to second question and assert a new QUESTION UPDATE ---
  757 |         const studentInfoBefore = await studentDiag.getInfoEvents();
  758 |         const answersBefore = await studentPage.locator('.tqcard-answer').allInnerTexts().catch(() => []);
  759 |         await switchToSecondQuestionAndStart(teacherPage);
  760 |         const startWait = Date.now();
  761 |         let gotNewQuestionLog = false;
  762 |         for (; ;) {
  763 |             const logs = await studentDiag.getInfoEvents();
  764 |             const beforeCount = studentInfoBefore.filter(l => l.text.includes('[QUESTION UPDATE]')).length;
  765 |             const afterCount = logs.filter(l => l.text.includes('[QUESTION UPDATE]')).length;
  766 |             if (afterCount > beforeCount) { gotNewQuestionLog = true; break; }
  767 |             if (Date.now() - startWait > 8000) break;
  768 |             await studentPage.waitForTimeout(200);
  769 |         }
> 770 |         expect(gotNewQuestionLog, 'Student should receive a new QUESTION UPDATE after teacher switches question').toBeTruthy();
      |                                                                                                                   ^ Error: Student should receive a new QUESTION UPDATE after teacher switches question
  771 |         await studentPage.waitForSelector('.tqcard-answer', { timeout: 15000 });
  772 |         const answersAfter = await studentPage.locator('.tqcard-answer').allInnerTexts().catch(() => []);
  773 |         if (answersBefore.length && answersAfter.length) {
  774 |             const changed = JSON.stringify(answersBefore) !== JSON.stringify(answersAfter);
  775 |             log('[QUESTION-SWITCH iPhone] answersChanged?', { changed, before: answersBefore.slice(0, 3), after: answersAfter.slice(0, 3) });
  776 |         }
  777 |     } finally {
  778 |         await teacherCtx.close();
  779 |         await studentCtx.close();
  780 |     }
  781 | });
  782 |
  783 | // Android Chrome emulation variant
  784 | test('android (Pixel 5) multiple-choice live: tap answer and overlay cycle', async ({ browser }) => {
  785 |     test.setTimeout(180000);
  786 |
  787 |     const teacherCtx = await browser.newContext();
  788 |     const teacherPage = await teacherCtx.newPage();
  789 |
  790 |     const studentCtx = await browser.newContext({ ...devices['Pixel 5'] });
  791 |     const studentPage = await studentCtx.newPage();
  792 |
  793 |     const teacherDiag = await setupCrashDiagnostics(teacherCtx, teacherPage, 'teacher-android');
  794 |     const studentDiag = await setupCrashDiagnostics(studentCtx, studentPage, 'student-android');
  795 |     // Ensure socket capture init script is injected in the student's browser context
  796 |     const studentSocketCap = await setupSocketCapture(studentCtx, studentPage, 'student-android');
  797 |
  798 |     try {
  799 |     const dataHelper = new TestDataHelper(teacherPage);
  800 |     await dataHelper.cleanDatabase();
  801 |     const teacherSeed = dataHelper.generateTestData('mc_android_teacher');
  802 |     await dataHelper.createTeacher({ username: teacherSeed.username, email: teacherSeed.email, password: teacherSeed.password });
  803 |     const loginHelper = new LoginHelper(teacherPage);
  804 |     await loginHelper.loginAsTeacher({ email: teacherSeed.email, password: teacherSeed.password });
  805 |     log('Teacher logged-in to frontend (Android test)');
  806 |     const { accessCode } = await createQuizViaFrontendApi(teacherPage);
  807 |
  808 |         const studentSeed = dataHelper.generateTestData('mc_android_student');
  809 |         await authenticateGuestStudent(studentPage, studentSeed.username);
  810 |         await studentPage.goto(`${CFG.baseUrl}/live/${accessCode}`);
  811 |         await studentPage.waitForURL(`${CFG.baseUrl}/live/${accessCode}`, { timeout: 15000 });
  812 |         await studentPage.waitForLoadState('networkidle');
  813 |         log('Android student is on live page');
  814 |         await studentDiag.clear(); // Clear pre-live errors to assert only live-page issues
  815 |     // Give sockets a brief moment to connect and ensure student joined the room
  816 |     await studentPage.waitForTimeout(800);
  817 |     await waitForStudentJoined(studentPage, studentDiag.getInfoEvents, 20000);
  818 |     await waitForServerRoomJoin(teacherPage, accessCode, 15000);
  819 |
  820 |         await startQuestionFromDashboard(teacherPage, accessCode);
  821 |
  822 |         // Early diagnostic: wait for initial QUESTION UPDATE logs from student (socket capture)
  823 |         {
  824 |             const start = Date.now();
  825 |             let sawInitialQuestion = false;
  826 |             for (;;) {
  827 |                 const infoLogs = await studentDiag.getInfoEvents();
  828 |                 if (infoLogs.some(l => l.text.includes('[QUESTION UPDATE]'))) { sawInitialQuestion = true; break; }
  829 |                 if (Date.now() - start > 8000) break;
  830 |                 await studentPage.waitForTimeout(200);
  831 |             }
  832 |             if (!sawInitialQuestion) {
  833 |                 const sock = await studentSocketCap.getEvents();
  834 |                 log('[ANDROID EARLY-DIAG no initial QUESTION UPDATE]', { totalSocketEvents: sock.length, last10: sock.slice(-10) });
  835 |             }
  836 |         }
  837 |
  838 |         // Stress: quick pause/resume toggles
  839 |         const playBtn = teacherPage.locator('ul.draggable-questions-list li .question-display [data-play-pause-btn]').first();
  840 |         if (await playBtn.count()) {
  841 |             for (let i = 0; i < 3; i++) {
  842 |                 await playBtn.click({ timeout: 5000 }).catch(() => { });
  843 |                 await teacherPage.waitForTimeout(250);
  844 |             }
  845 |         }
  846 |
  847 |         // Wait for timer bubble if present (proxy that the question started)
  848 |         await studentPage.waitForSelector('.navbar-timer-bg', { timeout: 20000 }).catch(() => { });
  849 |         // Recovery-aware wait: if answers don't appear promptly, ensure teacher state is playing,
  850 |         // and if still not, perform a stop/resume to re-sync student subscription.
  851 |         const ensureAnswersVisible = async () => {
  852 |             const answersVisible = await studentPage.locator('.tqcard-answer').first().isVisible().catch(() => false);
  853 |             if (answersVisible) return;
  854 |
  855 |             // Ensure we end in a PLAY state
  856 |             const playBtnNow = teacherPage.locator('ul.draggable-questions-list li .question-display [data-play-pause-btn]').first();
  857 |             if (await playBtnNow.count()) {
  858 |                 await playBtnNow.click({ timeout: 5000 }).catch(() => { });
  859 |                 await teacherPage.waitForTimeout(300);
  860 |             }
  861 |
  862 |             // Give student time to receive GAME_QUESTION
  863 |             await studentPage.waitForTimeout(1000);
  864 |             const visibleAfterPlay = await studentPage.locator('.tqcard-answer').first().isVisible().catch(() => false);
  865 |             if (visibleAfterPlay) return;
  866 |
  867 |             // As a last resort, stop then resume to trigger a fresh payload
  868 |             await stressStopResumeOnTeacher(teacherPage);
  869 |             await studentPage.waitForTimeout(1000);
  870 |         };
```