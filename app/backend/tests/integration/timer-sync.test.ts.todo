import { Server as SocketIOServer } from 'socket.io';
import { io as ioc, Socket as ClientSocket } from 'socket.io-client';
import { createServer, Server as HttpServer } from 'http';
import { setupSocketIO } from '@/sockets/socket';
import { prisma } from '@/db/prisma';
import { redisClient } from '@/config/redis';
import { GameInstance, GameTemplate, Question, User } from '@prisma/client';
import { DefaultEventsMap } from 'socket.io/dist/typed-events';
import { TEACHER_EVENTS, SOCKET_EVENTS } from '@shared/types/socket/events';
import * as jwt from 'jsonwebtoken';
import { GameTimerUpdatePayload } from '@shared/types/core/timer';

// Set up environment variables for testing
process.env.DATABASE_URL = "postgresql://postgre:dev123@localhost:5432/mathquest";
process.env.REDIS_URL = "redis://localhost:6379";
process.env.JWT_SECRET = "your key should be long and secure";
process.env.ADMIN_PASSWORD = "abc";
process.env.PORT = "3008"; // Use a different port to avoid conflicts
process.env.LOG_LEVEL = "info";

describe('Timer Synchronization Tests', () => {
    let io: SocketIOServer<DefaultEventsMap, DefaultEventsMap, DefaultEventsMap, any>;
    let httpServer: HttpServer;
    let serverAddress: string;
    let teacherSocket: ClientSocket, playerSocket: ClientSocket, projectionSocket: ClientSocket;
    let testUser: User, testGameTemplate: GameTemplate, testGameInstance: GameInstance, testQuestion: Question;
    let accessCode: string;
    let gameId: string;
    let token: string;

    // Helper to create a client socket
    const createClient = (authToken: string): ClientSocket => {
        return ioc(serverAddress, {
            auth: { token: authToken },
            transports: ['websocket'],
            forceNew: true,
        });
    };

    beforeAll(async () => {
        // Setup HTTP and Socket.IO server
        httpServer = createServer();
        io = new SocketIOServer(httpServer);
        setupSocketIO(io);
        await new Promise<void>(resolve => httpServer.listen(() => {
            const port = (httpServer.address() as any).port;
            serverAddress = `http://localhost:${port}`;
            resolve();
        }));

        // Create test data
        const now = Date.now();
        testUser = await prisma.user.create({
            data: {
                id: `user-timer-sync-${now}`,
                email: `user-timer-sync-${now}@test.com`,
                username: `UserTimerSync${now}`,
                password: 'password',
            },
        });

        token = jwt.sign({ userId: testUser.id, email: testUser.email }, process.env.JWT_SECRET as string);

        testGameTemplate = await prisma.gameTemplate.create({
            data: {
                id: `gt-timer-sync-${now}`,
                title: 'Timer Sync Test Template',
                description: 'A template for testing timer sync.',
                creatorId: testUser.id,
                isPublic: true,
            },
        });

        testQuestion = await prisma.question.create({
            data: {
                uid: `q-timer-sync-${now}`,
                text: 'What is 2+2?',
                questionType: 'numeric',
                timeLimit: 30,
                numericQuestion: { create: { correctAnswer: 4 } },
                gameTemplates: { create: { gameTemplateId: testGameTemplate.id, questionIndex: 0 } },
            },
        });

        testGameInstance = await prisma.gameInstance.create({
            data: {
                id: `game-timer-sync-${now}`,
                accessCode: `SYNC${now}`.slice(0, 10),
                status: 'pending',
                gameTemplateId: testGameTemplate.id,
                initiatorUserId: testUser.id,
            },
        });

        accessCode = testGameInstance.accessCode;
        gameId = testGameInstance.id;
    });

    afterAll(async () => {
        // Disconnect sockets
        if (teacherSocket?.connected) teacherSocket.disconnect();
        if (playerSocket?.connected) playerSocket.disconnect();
        if (projectionSocket?.connected) projectionSocket.disconnect();

        // Close server
        if (io) io.close();
        if (httpServer?.listening) httpServer.close();

        // Cleanup database
        await prisma.gameTemplateQuestion.deleteMany({ where: { gameTemplateId: testGameTemplate.id } });
        await prisma.question.delete({ where: { uid: testQuestion.uid } });
        await prisma.gameInstance.delete({ where: { id: testGameInstance.id } });
        await prisma.gameTemplate.delete({ where: { id: testGameTemplate.id } });
        await prisma.user.delete({ where: { id: testUser.id } });

        // Cleanup Redis
        await redisClient.del(`mathquest:game:${accessCode}`);
        await redisClient.quit();
    });

    beforeEach(done => {
        // Connect all clients
        teacherSocket = createClient(token);
        playerSocket = createClient(token); // Using same user for simplicity
        projectionSocket = createClient(token);

        const connections = [
            new Promise<void>(resolve => teacherSocket.on('connect', resolve)),
            new Promise<void>(resolve => playerSocket.on('connect', resolve)),
            new Promise<void>(resolve => projectionSocket.on('connect', resolve))
        ];

        Promise.all(connections).then(() => {
            // Join rooms after all sockets are connected
            const playerJoin = new Promise<void>(resolve => {
                playerSocket.emit(SOCKET_EVENTS.GAME.JOIN_GAME, { accessCode, userId: testUser.id, username: 'Player' });
                playerSocket.on(SOCKET_EVENTS.GAME.GAME_JOINED, () => resolve());
            });

            const projectionJoin = new Promise<void>(resolve => {
                projectionSocket.emit(SOCKET_EVENTS.PROJECTOR.JOIN_PROJECTION, { gameId });
                projectionSocket.on(SOCKET_EVENTS.PROJECTOR.PROJECTION_JOINED, () => resolve());
            });

            // For this test, we assume the teacher is implicitly in the dashboard room.
            // The main goal is to verify player and projection sync.
            Promise.all([playerJoin, projectionJoin]).then(() => done());
        });
    });

    it('should synchronize timer actions (run, pause, stop) across all clients', async () => {
        const testTimeout = 8000; // 8 seconds timeout for async operations

        // Helper to create a listener for a specific timer action
        const createListener = (socket: ClientSocket, action: 'run' | 'pause' | 'stop', clientName: string) => {
            return new Promise<GameTimerUpdatePayload>((resolve, reject) => {
                const timeoutId = setTimeout(() => {
                    reject(new Error(`Timeout waiting for '${action}' on ${clientName} socket`));
                }, testTimeout);

                // All clients should receive the same canonical event
                socket.on(SOCKET_EVENTS.GAME.GAME_TIMER_UPDATED, (payload: GameTimerUpdatePayload) => {
                    if (payload.timer.status === action) {
                        clearTimeout(timeoutId);
                        resolve(payload);
                    }
                });
            });
        };

        // --- Test RUN action ---
        console.log('Testing RUN action...');
        const playerRunPromise = createListener(playerSocket, 'run', 'Player');
        const projectionRunPromise = createListener(projectionSocket, 'run', 'Projection');

        teacherSocket.emit(TEACHER_EVENTS.TIMER_ACTION, {
            accessCode,
            action: 'run',
            questionUid: testQuestion.uid,
            durationMs: 30000,
        });

        const [playerPayloadRun, projectionPayloadRun] = await Promise.all([playerRunPromise, projectionRunPromise]);

        expect(playerPayloadRun.timer.status).toBe('run');
        expect(projectionPayloadRun.timer.status).toBe('run');
        expect(playerPayloadRun.questionUid).toBe(testQuestion.uid);
        expect(projectionPayloadRun.questionUid).toBe(testQuestion.uid);
        expect(projectionPayloadRun.timer.status).toBe('run');
        expect(playerPayloadRun.questionUid).toBe(testQuestion.uid);
        expect(projectionPayloadRun.questionUid).toBe(testQuestion.uid);

        // --- Test PAUSE action ---
        console.log('Testing PAUSE action...');
        const playerPausePromise = createListener(playerSocket, 'pause', 'Player');
        const projectionPausePromise = createListener(projectionSocket, 'pause', 'Projection');

        teacherSocket.emit(TEACHER_EVENTS.TIMER_ACTION, {
            accessCode,
            action: 'pause',
            questionUid: testQuestion.uid,
        });

        const [playerPayloadPause, projectionPayloadPause] = await Promise.all([playerPausePromise, projectionPausePromise]);

        expect(playerPayloadPause.timer.status).toBe('pause');
        expect(projectionPayloadPause.timer.status).toBe('pause');
        expect(playerPayloadPause.questionUid).toBe(testQuestion.uid);
        expect(projectionPayloadPause.questionUid).toBe(testQuestion.uid);

        // --- Test STOP action ---
        console.log('Testing STOP action...');
        const playerStopPromise = createListener(playerSocket, 'stop', 'Player');
        const projectionStopPromise = createListener(projectionSocket, 'stop', 'Projection');

        teacherSocket.emit(TEACHER_EVENTS.TIMER_ACTION, {
            accessCode,
            action: 'stop',
            questionUid: testQuestion.uid,
        });

        const [playerPayloadStop, projectionPayloadStop] = await Promise.all([playerStopPromise, projectionStopPromise]);

        expect(playerPayloadStop.timer.status).toBe('stop');
        expect(projectionPayloadStop.timer.status).toBe('stop');
        expect(playerPayloadStop.questionUid).toBe(testQuestion.uid);
        expect(projectionPayloadStop.questionUid).toBe(testQuestion.uid);
    });
});

