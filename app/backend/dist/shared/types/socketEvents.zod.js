"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sharedAnswerPayloadSchema = exports.sharedJoinPayloadSchema = exports.requestParticipantsPayloadSchema = exports.startGamePayloadSchema = exports.getParticipantsPayloadSchema = exports.leaveLobbyPayloadSchema = exports.joinLobbyPayloadSchema = exports.leaveProjectorPayloadSchema = exports.joinProjectorPayloadSchema = exports.startTournamentPayloadSchema = exports.pauseTimerPayloadSchema = exports.startTimerPayloadSchema = exports.serverToClientEventsSchema = exports.requestNextQuestionPayloadSchema = exports.gameJoinedPayloadSchema = exports.socketDataSchema = exports.interServerEventsSchema = exports.clientToServerEventsSchema = exports.leaderboardEntryDataSchema = exports.questionDataSchema = exports.notificationPayloadSchema = exports.playerJoinedGamePayloadSchema = exports.participantDataSchema = exports.gameAlreadyPlayedPayloadSchema = exports.errorPayloadSchema = exports.gameAnswerPayloadSchema = exports.joinGamePayloadSchema = exports.endGamePayloadSchema = exports.lockAnswersPayloadSchema = exports.timerActionPayloadSchema = exports.joinDashboardPayloadSchema = exports.setQuestionPayloadSchema = void 0;
// Generated by ts-to-zod
const zod_1 = require("zod");
// Teacher dashboard payload schemas
exports.setQuestionPayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
    questionUid: zod_1.z.string().min(1, { message: "Question UID cannot be empty." }),
    questionIndex: zod_1.z.number().int().nonnegative({ message: "Question index must be non-negative." }).optional(),
});
exports.joinDashboardPayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
});
exports.timerActionPayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
    action: zod_1.z.enum(['start', 'pause', 'resume', 'stop', 'set_duration'], {
        errorMap: () => ({ message: "Action must be one of: start, pause, resume, stop, set_duration" }),
    }),
    duration: zod_1.z.number().int().positive({ message: "Duration must be a positive integer." }).optional(),
    questionUid: zod_1.z.string().min(1, { message: "Question UID cannot be empty." }).optional(),
});
exports.lockAnswersPayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
    lock: zod_1.z.boolean({ errorMap: () => ({ message: "Lock must be a boolean value." }) }),
});
exports.endGamePayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
});
exports.joinGamePayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
    userId: zod_1.z.string().min(1, { message: "Player ID cannot be empty." }),
    username: zod_1.z.string().min(1, { message: "Username cannot be empty." }),
    avatarEmoji: zod_1.z.string().optional(),
    isDiffered: zod_1.z.boolean().optional(),
});
exports.gameAnswerPayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
    userId: zod_1.z.string().min(1, { message: "Player ID cannot be empty." }),
    questionUid: zod_1.z.string().min(1, { message: "Question UID cannot be empty." }),
    answer: zod_1.z.union([
        zod_1.z.string(),
        zod_1.z.number(),
        zod_1.z.array(zod_1.z.string()),
        zod_1.z.array(zod_1.z.number())
    ]),
    timeSpent: zod_1.z.number().int({ message: "Time spent must be an integer." }).nonnegative({ message: "Time spent cannot be negative." }),
});
exports.errorPayloadSchema = zod_1.z.object({
    message: zod_1.z.string().min(1, { message: "Error message cannot be empty." }),
    code: zod_1.z.union([zod_1.z.string(), zod_1.z.number()]).optional(),
    details: zod_1.z.record(zod_1.z.any()).optional(),
});
exports.gameAlreadyPlayedPayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
});
exports.participantDataSchema = zod_1.z.object({
    id: zod_1.z.string().min(1, { message: "Participant ID cannot be empty." }),
    userId: zod_1.z.string().min(1, { message: "Player ID cannot be empty." }),
    username: zod_1.z.string().min(1, { message: "Username cannot be empty." }),
    avatar: zod_1.z.string().min(1, { message: "Avatar cannot be empty." }),
    score: zod_1.z.number().int({ message: "Score must be an integer." }),
    avatarEmoji: zod_1.z.string().optional(), // For backward compatibility
    online: zod_1.z.boolean().optional(),
    joinedAt: zod_1.z.union([zod_1.z.string().datetime({ message: "Invalid datetime string for joinedAt" }), zod_1.z.number()]).optional(),
    socketId: zod_1.z.string().optional(),
    isDeferred: zod_1.z.boolean().optional(),
    cookieId: zod_1.z.string().optional(),
});
exports.playerJoinedGamePayloadSchema = zod_1.z.object({
    participant: exports.participantDataSchema,
});
exports.notificationPayloadSchema = zod_1.z.object({
    message: zod_1.z.string().min(1, { message: "Notification message cannot be empty." }),
    defaultMode: zod_1.z.enum(['info', 'warning', 'error', 'success']),
});
exports.questionDataSchema = zod_1.z.object({
    uid: zod_1.z.string().min(1, { message: "Question UID cannot be empty." }),
    title: zod_1.z.string().min(1).optional(),
    text: zod_1.z.string().min(1, { message: "Question text cannot be empty." }),
    answerOptions: zod_1.z.array(zod_1.z.string().min(1)).min(1, { message: "A question must have at least one answer option." }),
    correctAnswers: zod_1.z.array(zod_1.z.boolean()), // Now required everywhere
    questionType: zod_1.z.string().min(1, { message: "Question type cannot be empty." }),
    timeLimit: zod_1.z.number().int({ message: "Time limit must be an integer." }).positive({ message: "Time limit must be positive." }).optional(),
    currentQuestionIndex: zod_1.z.number().int({ message: "Question index must be an integer." }).nonnegative({ message: "Question index cannot be negative." }).optional(),
    totalQuestions: zod_1.z.number().int({ message: "Total questions must be an integer." }).positive({ message: "Total questions must be positive." }).optional(),
});
exports.leaderboardEntryDataSchema = zod_1.z.object({
    userId: zod_1.z.string().min(1, { message: "Player ID cannot be empty." }),
    username: zod_1.z.string().min(1, { message: "Username cannot be empty." }),
    avatarEmoji: zod_1.z.string().optional(),
    score: zod_1.z.number().int({ message: "Score must be an integer." }),
    rank: zod_1.z.number().int({ message: "Rank must be an integer." }).positive({ message: "Rank must be positive." }).optional(),
});
exports.clientToServerEventsSchema = zod_1.z.object({
    join_game: zod_1.z.function().args(exports.joinGamePayloadSchema).returns(zod_1.z.void()),
    game_answer: zod_1.z.function().args(exports.gameAnswerPayloadSchema).returns(zod_1.z.void()),
    request_participants: zod_1.z
        .function()
        .args(zod_1.z.object({
        accessCode: zod_1.z.string().min(1),
    }))
        .returns(zod_1.z.void()),
    teacher_set_question: zod_1.z
        .function()
        .args(zod_1.z.object({
        accessCode: zod_1.z.string().min(1),
        questionUid: zod_1.z.string().min(1),
        questionIndex: zod_1.z.number().int().nonnegative(),
    }))
        .returns(zod_1.z.void()),
    teacher_timer_action: zod_1.z
        .function()
        .args(zod_1.z.object({
        accessCode: zod_1.z.string().min(1),
        action: zod_1.z.enum([
            'start',
            'pause',
            'resume',
            'stop',
            'set_duration',
        ]),
        duration: zod_1.z.number().int().positive().optional(),
    }))
        .returns(zod_1.z.void()),
    teacher_lock_answers: zod_1.z
        .function()
        .args(zod_1.z.object({
        accessCode: zod_1.z.string().min(1),
        lock: zod_1.z.boolean(),
    }))
        .returns(zod_1.z.void()),
    teacher_end_game: zod_1.z
        .function()
        .args(zod_1.z.object({
        accessCode: zod_1.z.string().min(1),
    }))
        .returns(zod_1.z.void()),
});
exports.interServerEventsSchema = zod_1.z.object({});
exports.socketDataSchema = zod_1.z.object({
    userId: zod_1.z.string().min(1).optional(),
    username: zod_1.z.string().min(1).optional(),
    role: zod_1.z.enum(['player', 'teacher', 'admin', 'projector']).optional(),
    accessCode: zod_1.z.string().min(1).optional(),
    currentGameRoom: zod_1.z.string().min(1).optional(),
});
exports.gameJoinedPayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
    participant: exports.participantDataSchema,
    gameStatus: zod_1.z.enum(['pending', 'active', 'completed', 'archived']),
    isDiffered: zod_1.z.boolean(),
    differedAvailableFrom: zod_1.z.string().datetime({ message: "Invalid datetime string for differedAvailableFrom. Must be an ISO string." }).optional(),
    differedAvailableTo: zod_1.z.string().datetime({ message: "Invalid datetime string for differedAvailableTo. Must be an ISO string." }).optional(),
});
exports.requestNextQuestionPayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
    userId: zod_1.z.string().min(1, { message: "User ID cannot be empty." }),
    currentQuestionUid: zod_1.z.string().min(1, { message: "Current question UID cannot be empty." }),
});
exports.serverToClientEventsSchema = zod_1.z.object({
    connect: zod_1.z.function().args().returns(zod_1.z.void()),
    disconnect: zod_1.z.function().args(zod_1.z.string()).returns(zod_1.z.void()),
    connection_established: zod_1.z
        .function()
        .args(zod_1.z.object({
        socketId: zod_1.z.string().min(1),
        timestamp: zod_1.z.string().datetime(),
        user: exports.socketDataSchema.partial(),
    }))
        .returns(zod_1.z.void()),
    game_joined: zod_1.z.function().args(exports.gameJoinedPayloadSchema).returns(zod_1.z.void()),
    game_question: zod_1.z.function().args(exports.questionDataSchema).returns(zod_1.z.void()),
    answer_received: zod_1.z
        .function()
        .args(zod_1.z.object({
        questionUid: zod_1.z.string().min(1),
        timeSpent: zod_1.z.number().int().nonnegative(),
    }))
        .returns(zod_1.z.void()),
    leaderboard_update: zod_1.z
        .function()
        .args(zod_1.z.object({
        leaderboard: zod_1.z.array(exports.leaderboardEntryDataSchema),
    }))
        .returns(zod_1.z.void()),
    player_joined_game: zod_1.z
        .function()
        .args(exports.playerJoinedGamePayloadSchema)
        .returns(zod_1.z.void()),
    player_left_game: zod_1.z
        .function()
        .args(zod_1.z.object({
        userId: zod_1.z.string().min(1),
        socketId: zod_1.z.string().min(1),
    }))
        .returns(zod_1.z.void()),
    game_participants: zod_1.z
        .function()
        .args(zod_1.z.object({
        participants: zod_1.z.array(exports.participantDataSchema),
    }))
        .returns(zod_1.z.void()),
    game_state_update: zod_1.z.function().args(zod_1.z.any()).returns(zod_1.z.void()),
    timer_update: zod_1.z
        .function()
        .args(zod_1.z.object({
        timeLeftMs: zod_1.z.number().int().nonnegative().nullable(),
        running: zod_1.z.boolean(),
        durationMs: zod_1.z.number().int().positive().optional(),
    }))
        .returns(zod_1.z.void()),
    answers_locked: zod_1.z
        .function()
        .args(zod_1.z.object({
        locked: zod_1.z.boolean(),
    }))
        .returns(zod_1.z.void()),
    game_ended: zod_1.z
        .function()
        .args(zod_1.z.object({
        accessCode: zod_1.z.string().min(1),
    }))
        .returns(zod_1.z.void()),
    game_error: zod_1.z.function().args(exports.errorPayloadSchema).returns(zod_1.z.void()),
    game_already_played: zod_1.z
        .function()
        .args(exports.gameAlreadyPlayedPayloadSchema)
        .returns(zod_1.z.void()),
    notification: zod_1.z.function().args(exports.notificationPayloadSchema).returns(zod_1.z.void()),
    game_control_question_set: zod_1.z
        .function()
        .args(zod_1.z.object({
        questionIndex: zod_1.z.number().int().nonnegative(),
        timer: zod_1.z.object({
            startedAt: zod_1.z.number(),
            duration: zod_1.z.number(),
            isPaused: zod_1.z.boolean(),
            pausedAt: zod_1.z.number().optional(),
            timeRemaining: zod_1.z.number().optional()
        })
    }))
        .returns(zod_1.z.void()),
    game_control_question_ended: zod_1.z
        .function()
        .args(zod_1.z.object({
        questionUid: zod_1.z.string(),
        timer: zod_1.z.object({
            startedAt: zod_1.z.number(),
            duration: zod_1.z.number(),
            isPaused: zod_1.z.boolean(),
            pausedAt: zod_1.z.number().optional(),
            timeRemaining: zod_1.z.number().optional()
        })
    }))
        .returns(zod_1.z.void()),
    question_ended: zod_1.z
        .function()
        .args(zod_1.z.object({
        questionUid: zod_1.z.string(),
        showLeaderboard: zod_1.z.boolean().optional(),
        leaderboard: zod_1.z.array(zod_1.z.object({
            userId: zod_1.z.string(),
            username: zod_1.z.string(),
            avatarEmoji: zod_1.z.string().optional(),
            score: zod_1.z.number()
        })).optional()
    }))
        .returns(zod_1.z.void()),
    // Teacher dashboard socket event schemas
    set_question: zod_1.z.function().args(exports.setQuestionPayloadSchema).returns(zod_1.z.void()),
    join_dashboard: zod_1.z.function().args(exports.joinDashboardPayloadSchema).returns(zod_1.z.void()),
    timer_action: zod_1.z.function().args(exports.timerActionPayloadSchema).returns(zod_1.z.void()),
    lock_answers: zod_1.z.function().args(exports.lockAnswersPayloadSchema).returns(zod_1.z.void()),
    end_game: zod_1.z.function().args(exports.endGamePayloadSchema).returns(zod_1.z.void()),
});
// Additional teacher control schemas
exports.startTimerPayloadSchema = zod_1.z.object({
    gameId: zod_1.z.string().min(1, { message: "Game ID cannot be empty." }).optional(),
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }).optional(),
    duration: zod_1.z.number().int().positive({ message: "Duration must be a positive integer." }),
}).refine(data => data.gameId || data.accessCode, {
    message: "Either gameId or accessCode must be provided.",
});
exports.pauseTimerPayloadSchema = zod_1.z.object({
    gameId: zod_1.z.string().min(1, { message: "Game ID cannot be empty." }).optional(),
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }).optional(),
}).refine(data => data.gameId || data.accessCode, {
    message: "Either gameId or accessCode must be provided.",
});
// Tournament schemas
exports.startTournamentPayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
});
// Projector schemas
exports.joinProjectorPayloadSchema = zod_1.z.object({
    gameId: zod_1.z.string().min(1, { message: "Game ID cannot be empty." }),
});
exports.leaveProjectorPayloadSchema = zod_1.z.object({
    gameId: zod_1.z.string().min(1, { message: "Game ID cannot be empty." }),
});
// Lobby schemas
exports.joinLobbyPayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
    userId: zod_1.z.string().min(1, { message: "User ID cannot be empty." }),
    username: zod_1.z.string().min(1, { message: "Username cannot be empty." }),
    avatarEmoji: zod_1.z.string().optional(),
});
exports.leaveLobbyPayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
    userId: zod_1.z.string().min(1, { message: "User ID cannot be empty." }),
});
exports.getParticipantsPayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
});
// Game start schema
exports.startGamePayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
    userId: zod_1.z.string().min(1, { message: "User ID cannot be empty." }),
});
exports.requestParticipantsPayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
});
// Shared live handler schemas
exports.sharedJoinPayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
    userId: zod_1.z.string().min(1, { message: "User ID cannot be empty." }),
    username: zod_1.z.string().min(1, { message: "Username cannot be empty." }),
    avatarEmoji: zod_1.z.string().optional(),
    playMode: zod_1.z.enum(['quiz', 'tournament', 'practice']).optional(),
});
exports.sharedAnswerPayloadSchema = zod_1.z.object({
    accessCode: zod_1.z.string().min(1, { message: "Access code cannot be empty." }),
    userId: zod_1.z.string().min(1, { message: "User ID cannot be empty." }),
    questionUid: zod_1.z.string().min(1, { message: "Question UID cannot be empty." }),
    answer: zod_1.z.union([
        zod_1.z.string(),
        zod_1.z.number(),
        zod_1.z.array(zod_1.z.string()),
        zod_1.z.array(zod_1.z.number())
    ]),
    timeSpent: zod_1.z.number().int({ message: "Time spent must be an integer." }).nonnegative({ message: "Time spent cannot be negative." }),
    playMode: zod_1.z.enum(['quiz', 'tournament', 'practice']).optional(),
});
