import { useEffect, useState, useRef, useCallback } from 'react';
import { io, Socket } from 'socket.io-client';
import { createLogger } from '@/clientLogger';
import { SOCKET_CONFIG } from '@/config';
import { UI_CONFIG } from '@/config/gameConfig';
import { createSocketConfig } from '@/utils';
import { SOCKET_EVENTS } from '@shared/types/socket/events';
import { STORAGE_KEYS } from '@/constants/auth';

// Import unified timer system
import { useTeacherTimer } from './useGameTimer';

// Import core types instead of scattered imports
import type {
    Question,
    BaseAnswer,
    TimerUpdatePayload,
    GameTimerUpdatePayload,
    TimerActionPayload
} from '@shared/types/core';

// Import shared types
import type {
    QuestionData,
    ErrorPayload,
    TimerActionPayload as SharedTimerActionPayload
} from '@shared/types/socketEvents';
// Import type guards and teacher-specific types
import {
    isQuestionData,
    isErrorPayload,
    isTimerUpdatePayload,
    isGameTimerUpdatePayload,
    isTeacherQuizState,
    isTeacherTimerUpdatePayload,
    isGameErrorDetails,
    isLobbyErrorPayload,
    isConnectedCountPayload,
    isDashboardQuestionChangedPayload,
    isDashboardAnswersLockChangedPayload,
    isDashboardGameStatusChangedPayload,
    migrateTeacherTimerUpdate,
    validateEventPayload,
    createSafeEventHandler,
    SetQuestionPayload,
    TeacherTimerActionPayload,
    GameErrorDetails,
    LobbyErrorPayload,
    ConnectedCountPayload,
    DashboardQuestionChangedPayload,
    DashboardAnswersLockChangedPayload,
    DashboardGameStatusChangedPayload,
    TeacherQuizState,
    TeacherTimerUpdatePayload
} from '@/types/socketTypeGuards';

const logger = createLogger('useTeacherQuizSocket');

// --- Types (Consider moving to a shared types file if used elsewhere) ---
// Use shared types for questions in QuizState
// Remove custom Question interface and use QuestionData from shared types
// Note: QuestionData fields: uid, text, answerOptions, correctAnswers, questionType, timeLimit, etc.
export interface QuizState {
    currentQuestionIdx: number | null;
    questions: QuestionData[];
    chrono: { timeLeft: number | null; running: boolean };
    locked: boolean;
    ended: boolean;
    stats: Record<string, unknown>;
    profSocketId?: string | null;
    timerStatus?: 'play' | 'pause' | 'stop' | null;
    timerQuestionId?: string | null;
    timerTimeLeft?: number | null;
    timerTimestamp?: number;
    questionStates?: Record<string, boolean>;
}

// New interface for per-question timer state
interface QuestionTimerState {
    status: 'play' | 'pause' | 'stop';
    timeLeft: number;
    timestamp: number | null;
    initialTime?: number; // Added to store the original timer value for resetting
}

export function useTeacherQuizSocket(accessCode: string | null, token: string | null, quizId?: string | null) {
    const [quizSocket, setQuizSocket] = useState<Socket | null>(null);
    const [quizState, setQuizState] = useState<QuizState | null>(null);
    const [connectedCount, setConnectedCount] = useState<number>(1); // 1 = prof connecté par défaut

    // Use unified timer system for teacher control
    const gameTimer = useTeacherTimer(quizSocket, {
        autoStart: false,
        smoothCountdown: false,
        showMilliseconds: false,
        enableLocalAnimation: false
    });

    // Legacy timer state for backward compatibility - now derived from unified timer
    const timerStatus = gameTimer.timerState.status;
    const timerQuestionId = gameTimer.timerState.questionId || null;
    const timeLeft = Math.floor(gameTimer.timerState.timeLeft / 1000);
    const localTimeLeft = gameTimer.timerState.localTimeLeft ? Math.floor(gameTimer.timerState.localTimeLeft / 1000) : null;

    // Maintain per-question timer states for backward compatibility
    const [questionTimers, setQuestionTimers] = useState<Record<string, QuestionTimerState>>({});

    // --- Debounced logging for timer updates ---
    const lastLoggedTimerRef = useRef<Record<string, { status: string; intTimeLeft: number | null }>>({});

    // Sync unified timer state with question timers for backward compatibility
    useEffect(() => {
        if (!timerQuestionId) return;
        
        setQuestionTimers(prev => ({
            ...prev,
            [timerQuestionId]: {
                status: timerStatus,
                timeLeft: timeLeft,
                timestamp: Date.now(),
                initialTime: prev[timerQuestionId]?.initialTime || timeLeft
            }
        }));
    }, [timerStatus, timerQuestionId, timeLeft]);

    // --- Socket Connection ---
    useEffect(() => {
        if (!quizId || !token) return;

        logger.info(`Initializing socket connection for quiz: ${quizId} to ${SOCKET_CONFIG.url}`);

        // Create socket configuration with authentication
        const socketConfig = createSocketConfig(SOCKET_CONFIG);
        const s = io(SOCKET_CONFIG.url, socketConfig);

        // Manually connect after setting up auth
        s.connect();
        setQuizSocket(s);

        s.on(SOCKET_EVENTS.CONNECT, () => {
            logger.info(`Socket connected: ${s.id}`);

            // Use Phase 8 dashboard join event with gameId parameter
            logger.info(`[DEBUG][CLIENT] Emitting join_dashboard for gameId=${quizId}`);
            s.emit(SOCKET_EVENTS.TEACHER.JOIN_DASHBOARD, { gameId: quizId });

            // Note: No need for separate GET_GAME_STATE - join_dashboard returns comprehensive state
        });

        // Register connect and disconnect event listeners for test compatibility
        s.on('connect', () => {
            logger.info(`Socket connected: ${s.id}`);
            // Use Phase 8 dashboard join event with gameId parameter
            logger.info(`[DEBUG][CLIENT] Emitting join_dashboard for gameId=${quizId}`);
            s.emit(SOCKET_EVENTS.TEACHER.JOIN_DASHBOARD, { gameId: quizId });
        });
        s.on('disconnect', (reason) => {
            logger.warn(`Socket disconnected: ${reason}`);
            // Reset state on disconnect
            setQuizState(null);
            setTimerStatus('stop');
            setTimerQuestionId(null);
            setTimeLeft(0);
            setLocalTimeLeft(null);
        });

        s.on(SOCKET_EVENTS.CONNECT_ERROR, (err) => {
            logger.error("Socket connection error:", err);
        });

        s.on(SOCKET_EVENTS.TEACHER.DASHBOARD_JOINED, ({ room, socketId }) => {
            logger.debug("Server confirms dashboard join", { room, socketId });
        });

        return () => {
            logger.info(`Disconnecting socket for quiz: ${quizId}`);
            s.disconnect();
            setQuizSocket(null);
        };
    }, [quizId, token]);

    // --- State Synchronization with Backend ---
    useEffect(() => {
        if (!quizSocket) return;

        const handleGameControlState = createSafeEventHandler(
            (state: TeacherQuizState) => {
                logger.debug('Processing game_control_state', state);

                // Use state.questions as-is (should already be QuestionData[])
                const convertedState: QuizState = {
                    ...state,
                    questions: state.questions as QuestionData[]
                };

                setQuizState(convertedState);

                // Always trust the backend state for timer values
                if (state && state.timerStatus) {
                    // Sync unified timer with backend state
                    if (state.timerStatus === 'play' && state.timerQuestionId) {
                        gameTimer.start(state.timerQuestionId, state.timerTimeLeft || 0);
                    } else if (state.timerStatus === 'pause') {
                        gameTimer.pause();
                    } else {
                        gameTimer.stop();
                    }
                }

                if (state && state.timerQuestionId) {
                    setTimerQuestionId(state.timerQuestionId);
                } else if (state && state.currentQuestionIdx !== null && state.questions && state.questions[state.currentQuestionIdx]) {
                    setTimerQuestionId(state.questions[state.currentQuestionIdx].uid);
                }

                // Update timeLeft from backend values with null safety
                if (state && state.timerTimeLeft !== undefined && state.timerTimeLeft !== null) {
                    setTimeLeft(state.timerTimeLeft);
                } else if (state && state.chrono && state.chrono.timeLeft !== null) {
                    setTimeLeft(state.chrono.timeLeft);
                }

                // Initialize per-question timers for all questions
                if (state && state.questions) {
                    setQuestionTimers(prev => {
                        const newTimers: Record<string, QuestionTimerState> = { ...prev };
                        state.questions.forEach(q => {
                            if (!newTimers[q.uid]) {
                                newTimers[q.uid] = {
                                    status: state.timerStatus || 'stop',
                                    timeLeft: (q.uid === state.timerQuestionId && state.timerTimeLeft != null)
                                        ? state.timerTimeLeft
                                        : (q.timeLimit || 0),
                                    initialTime: q.timeLimit || 0,
                                    timestamp: null
                                };
                            } else {
                                if (q.uid === state.timerQuestionId && state.timerTimeLeft != null) {
                                    newTimers[q.uid] = {
                                        ...newTimers[q.uid],
                                        status: state.timerStatus || 'stop',
                                        timeLeft: state.timerTimeLeft,
                                        timestamp: null
                                    };
                                }
                            }
                        });
                        return newTimers;
                    });
                }
            },
            isTeacherQuizState,
            'game_control_state'
        );

        // Handle timer updates - support both shared and legacy formats using unified timer
        const handleTimerUpdate = (data: unknown) => {
            // Try shared format first
            const sharedTimer = validateEventPayload(data, isTimerUpdatePayload, 'timer_update_shared');
            if (sharedTimer) {
                logger.debug('Received shared format timer update', sharedTimer);
                
                // Use unified timer's syncWithBackend method
                gameTimer.syncWithBackend(sharedTimer);

                // Update per-question timer state for backward compatibility
                if (sharedTimer.questionId) {
                    const teacherStatus = sharedTimer.running ? 'play' : (sharedTimer.status === 'stop' ? 'stop' : 'pause');
                    setQuestionTimers(prev => ({
                        ...prev,
                        [sharedTimer.questionId!]: {
                            status: teacherStatus,
                            timeLeft: sharedTimer.timeLeft || 0,
                            timestamp: Date.now(),
                            initialTime: prev[sharedTimer.questionId!]?.initialTime || sharedTimer.timeLeft || 0
                        }
                    }));
                }

                return;
            }

            // Try legacy teacher format
            const teacherTimer = validateEventPayload(data, isTeacherTimerUpdatePayload, 'timer_update_teacher');
            if (teacherTimer) {
                logger.debug('Received legacy teacher timer update', teacherTimer);

                // Debounced/deduplicated logging for timer updates
                const { questionId, timeLeft, status } = teacherTimer;
                const intTimeLeft = Math.floor(timeLeft);
                const last = lastLoggedTimerRef.current[questionId] || { status: '', intTimeLeft: null };
                if (last.status !== status || last.intTimeLeft !== intTimeLeft) {
                    logger.info(`[TIMER UPDATE] Question ${questionId}: status=${status}, timeLeft=${intTimeLeft}s`);
                    lastLoggedTimerRef.current[questionId] = { status, intTimeLeft };
                }

                // Convert to TimerUpdatePayload format for unified timer
                const unifiedPayload: TimerUpdatePayload = {
                    running: teacherTimer.status === 'play',
                    status: teacherTimer.status,
                    timeLeft: teacherTimer.timeLeft,
                    questionId: teacherTimer.questionId
                };

                // Use unified timer's syncWithBackend method
                gameTimer.syncWithBackend(unifiedPayload);

                // Update the per-question timer state for UI consistency
                setQuestionTimers(prev => ({
                    ...prev,
                    [teacherTimer.questionId]: {
                        status: teacherTimer.status,
                        timeLeft: teacherTimer.timeLeft,
                        timestamp: teacherTimer.timestamp || Date.now(),
                        initialTime: prev[teacherTimer.questionId]?.initialTime || teacherTimer.timeLeft
                    }
                }));

                logger.debug(`[TIMER OVERHAUL] Updated timer display to ${teacherTimer.timeLeft}s (status: ${teacherTimer.status})`);
                return;
            }

            // Log if no format matched
            logger.warn('Received timer update in unknown format:', data);
        };

        // Handle backend error events with type safety
        const handleErrorDashboard = createSafeEventHandler(
            (error: ErrorPayload) => {
                logger.error('Dashboard error received:', error);

                // You can add UI notification logic here
                // For example, show a toast notification or update error state

                // If the error is authentication-related, you might want to redirect to login
                if (error.code === 'AUTHENTICATION_REQUIRED' || error.code === 'NOT_AUTHORIZED') {
                    logger.warn('Authentication error - may need to re-authenticate');
                    // Could emit a custom event or update local state to handle auth errors
                }

                // For timer-related errors, reset timer state and log specific message
                if (error.code === 'TIMER_ERROR') {
                    logger.error(`Timer error: ${error.message}`);
                    gameTimer.stop();
                }
            },
            isErrorPayload,
            'error_dashboard'
        );

        const handleGameError = createSafeEventHandler(
            (error: GameErrorDetails) => {
                logger.error('Game error received:', error);

                // Handle specific game errors
                if (error.code === 'INVALID_PAYLOAD') {
                    logger.error('Payload validation error');
                }
            },
            isGameErrorDetails,
            'game_error'
        );

        const handleLobbyError = createSafeEventHandler(
            (error: LobbyErrorPayload) => {
                logger.error('Lobby error received:', error);
            },
            isLobbyErrorPayload,
            'lobby_error'
        );

        // Enhanced connection error handling
        const handleConnectError = (error: Error) => {
            logger.error('Socket connection error:', error);
            // Reset state on connection errors
            setQuizState(null);
            setTimerStatus('stop');
            setTimeLeft(0);
            setLocalTimeLeft(null);
        };

        const handleDisconnect = (reason: string) => {
            logger.warn('Socket disconnected:', reason);
            // Reset state on disconnect
            setQuizState(null);
            setTimerStatus('stop');
            setTimerQuestionId(null);
            setTimeLeft(0);
            setLocalTimeLeft(null);
        };

        // Register Phase 8 event handlers
        quizSocket.on(SOCKET_EVENTS.TEACHER.GAME_CONTROL_STATE, handleGameControlState);

        // Register specific dashboard update events from Phase 8 with type safety
        const handleDashboardQuestionChanged = createSafeEventHandler(
            (payload: DashboardQuestionChangedPayload) => {
                logger.debug('Received dashboard_question_changed', payload);
                setTimerQuestionId(payload.questionUid);
                if (payload.timer && payload.timer.timeRemaining !== undefined) {
                    setTimeLeft(payload.timer.timeRemaining);
                    setLocalTimeLeft(payload.timer.timeRemaining);
                }
            },
            isDashboardQuestionChangedPayload,
            'dashboard_question_changed'
        );

        const handleDashboardAnswersLockChanged = createSafeEventHandler(
            (payload: DashboardAnswersLockChangedPayload) => {
                logger.debug('Received dashboard_answers_lock_changed', payload);
                // Update locked state in quizState if needed
                if (quizState) {
                    setQuizState(prev => prev ? { ...prev, locked: payload.answersLocked } : prev);
                }
            },
            isDashboardAnswersLockChangedPayload,
            'dashboard_answers_lock_changed'
        );

        const handleDashboardGameStatusChanged = createSafeEventHandler(
            (payload: DashboardGameStatusChangedPayload) => {
                logger.debug('Received dashboard_game_status_changed', payload);
                // Update game status in quizState if needed
                if (quizState) {
                    setQuizState(prev => prev ? { ...prev, ended: payload.status === 'completed' } : prev);
                }
            },
            isDashboardGameStatusChangedPayload,
            'dashboard_game_status_changed'
        );

        const handleConnectedCount = createSafeEventHandler(
            (payload: ConnectedCountPayload) => {
                logger.debug('Received quiz_connected_count', payload);
                setConnectedCount(payload.count);
            },
            isConnectedCountPayload,
            'connected_count'
        );

        quizSocket.on(SOCKET_EVENTS.TEACHER.DASHBOARD_QUESTION_CHANGED, handleDashboardQuestionChanged);
        quizSocket.on(SOCKET_EVENTS.TEACHER.DASHBOARD_TIMER_UPDATED, handleTimerUpdate);
        quizSocket.on(SOCKET_EVENTS.TEACHER.DASHBOARD_ANSWERS_LOCK_CHANGED, handleDashboardAnswersLockChanged);
        quizSocket.on(SOCKET_EVENTS.TEACHER.DASHBOARD_GAME_STATUS_CHANGED, handleDashboardGameStatusChanged);

        // Legacy timer update for backward compatibility
        quizSocket.on(SOCKET_EVENTS.TEACHER.TIMER_UPDATE, handleTimerUpdate);

        quizSocket.on(SOCKET_EVENTS.TEACHER.CONNECTED_COUNT, handleConnectedCount);

        // Error event handlers
        quizSocket.on(SOCKET_EVENTS.TEACHER.ERROR_DASHBOARD, handleErrorDashboard);
        quizSocket.on(SOCKET_EVENTS.GAME.GAME_ERROR, handleGameError);
        quizSocket.on(SOCKET_EVENTS.LOBBY.LOBBY_ERROR, handleLobbyError);
        quizSocket.on(SOCKET_EVENTS.CONNECT_ERROR, handleConnectError);
        quizSocket.on(SOCKET_EVENTS.DISCONNECT, handleDisconnect);

        // Request state again if socket reconnects (e.g., after server restart)
        quizSocket.on(SOCKET_EVENTS.CONNECT, () => {
            logger.info("Reconnected, rejoining dashboard with gameId.");
            quizSocket.emit(SOCKET_EVENTS.TEACHER.JOIN_DASHBOARD, { gameId: quizId });
        });

        return () => {
            // Cleanup all event listeners
            quizSocket.off(SOCKET_EVENTS.TEACHER.GAME_CONTROL_STATE, handleGameControlState);
            quizSocket.off(SOCKET_EVENTS.TEACHER.DASHBOARD_QUESTION_CHANGED, handleDashboardQuestionChanged);
            quizSocket.off(SOCKET_EVENTS.TEACHER.DASHBOARD_TIMER_UPDATED, handleTimerUpdate);
            quizSocket.off(SOCKET_EVENTS.TEACHER.DASHBOARD_ANSWERS_LOCK_CHANGED, handleDashboardAnswersLockChanged);
            quizSocket.off(SOCKET_EVENTS.TEACHER.DASHBOARD_GAME_STATUS_CHANGED, handleDashboardGameStatusChanged);
            quizSocket.off(SOCKET_EVENTS.TEACHER.TIMER_UPDATE, handleTimerUpdate);
            quizSocket.off(SOCKET_EVENTS.TEACHER.CONNECTED_COUNT, handleConnectedCount);
            quizSocket.off(SOCKET_EVENTS.TEACHER.ERROR_DASHBOARD, handleErrorDashboard);
            quizSocket.off(SOCKET_EVENTS.GAME.GAME_ERROR, handleGameError);
            quizSocket.off(SOCKET_EVENTS.LOBBY.LOBBY_ERROR, handleLobbyError);
            quizSocket.off(SOCKET_EVENTS.CONNECT_ERROR, handleConnectError);
            quizSocket.off(SOCKET_EVENTS.DISCONNECT, handleDisconnect);
            quizSocket.off(SOCKET_EVENTS.CONNECT);
        };
    }, [quizSocket, quizId, timerStatus, timerQuestionId, quizState]);

    // --- Backend-Driven Question Timer State Management ---
    useEffect(() => {
        if (!quizState || !quizState.questions || !timerQuestionId) return;

        const question = quizState.questions.find(q => q.uid === timerQuestionId);
        if (!question) return;

        // TIMER MANAGEMENT OVERHAUL: Simplified question timer initialization
        // Only initialize timer state if it doesn't exist, let backend control the values
        setQuestionTimers(prev => {
            if (!prev[timerQuestionId]) {
                logger.debug(`[TIMER OVERHAUL] Initializing timer state for question ${timerQuestionId}`);
                return {
                    ...prev,
                    [timerQuestionId]: {
                        status: 'stop',
                        timeLeft: question.timeLimit || 0,
                        initialTime: question.timeLimit || 0,
                        timestamp: null
                    }
                };
            }
            return prev;
        });
    }, [timerQuestionId, quizState]);

    // --- Simple Display Timer Update ---
    useEffect(() => {
        if (!timerQuestionId || !questionTimers[timerQuestionId]) return;

        const questionTimer = questionTimers[timerQuestionId];

        // TIMER MANAGEMENT OVERHAUL: Simple display update from stored state
        if (questionTimer.timeLeft !== undefined) {
            setTimeLeft(questionTimer.timeLeft);
            setLocalTimeLeft(questionTimer.timeLeft);
            logger.debug(`[TIMER OVERHAUL] Display updated for question ${timerQuestionId}: ${questionTimer.timeLeft}s`);
        }
    }, [timerQuestionId, questionTimers]);

    // --- Internal UI Timer for Smooth Countdown Display ---
    useEffect(() => {
        // TIMER MANAGEMENT OVERHAUL: Implement proper internal UI timer
        // Backend provides discrete timer events, frontend provides smooth countdown display

        // Clear any existing timer/animation frame
        if (timerRef.current) {
            clearInterval(timerRef.current);
            timerRef.current = null;
        }
        if (animationFrameRef.current) {
            cancelAnimationFrame(animationFrameRef.current);
            animationFrameRef.current = null;
        }

        if (!timerQuestionId || timerStatus === 'stop') {
            // When stopped, display the backend-provided timeLeft value
            if (timeLeft !== null) {
                setLocalTimeLeft(timeLeft);
            }
            return;
        }

        if (timerStatus === 'pause') {
            // When paused, show the current backend value without countdown
            if (timeLeft !== null) {
                setLocalTimeLeft(timeLeft);
            }
            return;
        }

        if (timerStatus === 'play' && timeLeft !== null && timeLeft > 0) {
            // Start internal countdown from backend-provided value
            startTimeRef.current = Date.now();
            initialDurationRef.current = timeLeft;
            setLocalTimeLeft(timeLeft);

            logger.debug(`[TIMER OVERHAUL] Starting internal countdown from ${timeLeft}s`);

            // Use requestAnimationFrame for smooth countdown
            const tick = () => {
                if (startTimeRef.current === null || initialDurationRef.current === null) return;

                const now = Date.now();
                const elapsed = (now - startTimeRef.current) / 1000;
                const remaining = Math.max(initialDurationRef.current - elapsed, 0);
                const roundedRemaining = Math.floor(remaining);

                // Update display with throttling
                updateLocalTimeLeft(roundedRemaining);

                if (remaining <= 0) {
                    // Timer finished - stop countdown but don't change timer status
                    // Backend will send the authoritative timer event
                    if (animationFrameRef.current) {
                        cancelAnimationFrame(animationFrameRef.current);
                        animationFrameRef.current = null;
                    }
                    startTimeRef.current = null;
                    initialDurationRef.current = null;
                } else {
                    // Continue countdown
                    animationFrameRef.current = requestAnimationFrame(tick);
                }
            };

            animationFrameRef.current = requestAnimationFrame(tick);
        }

        // Note: No local countdown logic - backend will send timer updates as needed
        // This eliminates sync issues and ensures backend is single source of truth
    }, [timerStatus, timeLeft, timerQuestionId]);

    // --- Emitter Functions ---
    const getTeacherId = () => (typeof window !== 'undefined' ? localStorage.getItem(STORAGE_KEYS.TEACHER_ID) : null);

    // Updated emitSetQuestion to use Phase 8 backend event format
    const emitSetQuestion = useCallback((questionUid: string, startTime?: number) => {
        let effectiveStartTime = startTime;
        if (startTime === undefined && questionTimers[questionUid]) {
            if (questionTimers[questionUid].status === 'pause' && questionTimers[questionUid].timeLeft > 0) {
                effectiveStartTime = questionTimers[questionUid].timeLeft;
                logger.info(`[UI TIMER FIX] Using preserved paused timer value (${effectiveStartTime}s) for question ${questionUid}`);
            } else if (questionTimers[questionUid].status === 'play' && questionTimers[questionUid].timeLeft > 0) {
                effectiveStartTime = questionTimers[questionUid].timeLeft;
                logger.info(`[UI TIMER FIX] Using stored timer value (${effectiveStartTime}s) for previously playing question ${questionUid}`);
            }
        }
        logger.info(`Emitting set_question with gameId=${quizId}, questionUid=${questionUid}`);
        const payload: any = {
            gameId: quizId!,
            questionUid
        };
        if (accessCode) payload.accessCode = accessCode;
        quizSocket?.emit(SOCKET_EVENTS.TEACHER.SET_QUESTION, payload);
        setTimerQuestionId(questionUid);
        logger.info(`Waiting for backend confirmation of question ${questionUid}`);
    }, [quizSocket, quizId, accessCode, questionTimers, quizState]);

    // Updated emitEndQuiz to use new backend event format
    const emitEndQuiz = useCallback(() => {
        if (!quizId) return;
        logger.info('Emitting end_game', { gameId: quizId });
        const payload: any = { gameId: quizId };
        if (accessCode) payload.accessCode = accessCode;
        quizSocket?.emit(SOCKET_EVENTS.TEACHER.END_GAME, payload);
    }, [quizSocket, quizId, accessCode]);

    // Updated emitPauseQuiz to use new timer action system
    const emitPauseQuiz = useCallback(() => {
        if (!quizId) return;
        logger.info('Emitting quiz_timer_action with action=pause', { gameId: quizId });
        const payload: any = { gameId: quizId, action: 'pause' };
        if (accessCode) payload.accessCode = accessCode;
        quizSocket?.emit(SOCKET_EVENTS.TEACHER.TIMER_ACTION, payload);
    }, [quizSocket, quizId, accessCode]);

    // Updated emitResumeQuiz to use new timer action system  
    const emitResumeQuiz = useCallback(() => {
        if (!quizId) return;
        logger.info('Emitting quiz_timer_action with action=resume', { gameId: quizId });
        const payload: any = { gameId: quizId, action: 'resume' };
        if (accessCode) payload.accessCode = accessCode;
        quizSocket?.emit(SOCKET_EVENTS.TEACHER.TIMER_ACTION, payload);
    }, [quizSocket, quizId, accessCode]);

    // Updated emitSetTimer to use new backend event format with set_duration action
    const emitSetTimer = useCallback((newTime: number, questionUid?: string) => {
        if (!quizId) return;
        logger.info('Emitting quiz_timer_action with action=set_duration', {
            gameId: quizId,
            duration: newTime
        });
        const payload: any = { gameId: quizId, action: 'set_duration', duration: newTime };
        if (accessCode) payload.accessCode = accessCode;
        quizSocket?.emit(SOCKET_EVENTS.TEACHER.TIMER_ACTION, payload);
    }, [quizSocket, quizId, accessCode]);

    // Updated emitTimerAction to use Phase 8 backend event format
    const emitTimerAction = useCallback((action: { status: 'play' | 'pause' | 'stop', questionId: string, timeLeft?: number }) => {
        if (!quizId) return;
        let backendAction: 'start' | 'pause' | 'resume' | 'stop' | 'set_duration';
        switch (action.status) {
            case 'play':
                backendAction = 'start';
                break;
            case 'pause':
                backendAction = 'pause';
                break;
            case 'stop':
                backendAction = 'stop';
                break;
            default:
                backendAction = 'stop';
        }
        const payload: any = { gameId: quizId, action: backendAction };
        if (accessCode) payload.accessCode = accessCode;
        if (action.timeLeft !== undefined) {
            payload.duration = action.timeLeft;
        }
        logger.info(`Emitting quiz_timer_action with gameId=${quizId}, action=${backendAction}`, payload);
        quizSocket?.emit(SOCKET_EVENTS.TEACHER.TIMER_ACTION, payload);
    }, [quizSocket, quizId, accessCode]);

    // Updated emitLockAnswers to use Phase 8 backend event format
    const emitLockAnswers = useCallback((lock: boolean) => {
        if (!quizId) return;
        logger.info(`Emitting lock_answers with gameId=${quizId}, lock=${lock}`);
        const payload: any = { gameId: quizId, lock: lock };
        if (accessCode) payload.accessCode = accessCode;
        quizSocket?.emit(SOCKET_EVENTS.TEACHER.LOCK_ANSWERS, payload);
    }, [quizSocket, quizId, accessCode]);

    // NOTE: Tournament code functionality removed as it's not supported in the new backend architecture
    // The new backend uses accessCode system instead of tournament codes
    const emitUpdateTournamentCode = useCallback((newCode: string) => {
        logger.warn('emitUpdateTournamentCode called but this functionality is deprecated in the new backend architecture');
        logger.info('Use the new accessCode system instead of tournament codes');
        // No longer emit anything as this functionality is not supported
    }, []);

    // Expose the updated methods
    return {
        quizSocket,
        quizState,
        timerStatus,
        timerQuestionId,
        timeLeft,
        localTimeLeft,
        connectedCount,
        questionTimers, // NEW: Expose per-question timer states
        emitSetQuestion,
        emitEndQuiz,
        emitPauseQuiz,
        emitResumeQuiz,
        emitSetTimer,
        emitTimerAction,
        emitLockAnswers, // NEW: Phase 8 answer lock control
        emitUpdateTournamentCode,
    };
}
