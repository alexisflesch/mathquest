// Generated by ts-to-zod
import { z } from 'zod';

export const joinGamePayloadSchema = z.object({
  accessCode: z.string().min(1, { message: "Access code cannot be empty." }),
  userId: z.string().min(1, { message: "Player ID cannot be empty." }),
  username: z.string().min(1, { message: "Username cannot be empty." }),
  avatarEmoji: z.string().optional(),
  isDiffered: z.boolean().optional(),
});

export const gameAnswerPayloadSchema = z.object({
  accessCode: z.string().min(1, { message: "Access code cannot be empty." }),
  userId: z.string().min(1, { message: "Player ID cannot be empty." }),
  questionId: z.string().min(1, { message: "Question ID cannot be empty." }),
  answer: z.union([
    z.string(),
    z.number(),
    z.array(z.string()),
    z.array(z.number())
  ]),
  timeSpent: z.number().int({ message: "Time spent must be an integer." }).nonnegative({ message: "Time spent cannot be negative." }),
});

export const errorPayloadSchema = z.object({
  message: z.string().min(1, { message: "Error message cannot be empty." }),
  code: z.union([z.string(), z.number()]).optional(),
  details: z.record(z.any()).optional(),
});

export const gameAlreadyPlayedPayloadSchema = z.object({
  accessCode: z.string().min(1, { message: "Access code cannot be empty." }),
});

export const participantDataSchema = z.object({
  id: z.string().min(1, { message: "Participant ID cannot be empty." }),
  userId: z.string().min(1, { message: "Player ID cannot be empty." }),
  username: z.string().min(1, { message: "Username cannot be empty." }),
  avatarEmoji: z.string().optional(),
  score: z.number().int({ message: "Score must be an integer." }).optional(),
  online: z.boolean().optional(),
  joinedAt: z.union([z.string().datetime({ message: "Invalid datetime string for joinedAt" }), z.number()]).optional(),
});

export const playerJoinedGamePayloadSchema = z.object({
  participant: participantDataSchema,
});

export const notificationPayloadSchema = z.object({
  message: z.string().min(1, { message: "Notification message cannot be empty." }),
  type: z.enum(['info', 'warning', 'error', 'success']),
});

export const questionDataSchema = z.object({
  uid: z.string().min(1, { message: "Question UID cannot be empty." }),
  title: z.string().min(1).optional(),
  text: z.string().min(1, { message: "Question text cannot be empty." }),
  answerOptions: z.array(z.string().min(1)).min(1, { message: "A question must have at least one answer option." }),
  correctAnswers: z.array(z.boolean()), // Now required everywhere
  questionType: z.string().min(1, { message: "Question type cannot be empty." }),
  timeLimit: z.number().int({ message: "Time limit must be an integer." }).positive({ message: "Time limit must be positive." }).optional(),
  currentQuestionIndex: z.number().int({ message: "Question index must be an integer." }).nonnegative({ message: "Question index cannot be negative." }).optional(),
  totalQuestions: z.number().int({ message: "Total questions must be an integer." }).positive({ message: "Total questions must be positive." }).optional(),
});

export const leaderboardEntryDataSchema = z.object({
  userId: z.string().min(1, { message: "Player ID cannot be empty." }),
  username: z.string().min(1, { message: "Username cannot be empty." }),
  avatarEmoji: z.string().optional(),
  score: z.number().int({ message: "Score must be an integer." }),
  rank: z.number().int({ message: "Rank must be an integer." }).positive({ message: "Rank must be positive." }).optional(),
});

export const clientToServerEventsSchema = z.object({
  join_game: z.function().args(joinGamePayloadSchema).returns(z.void()),
  game_answer: z.function().args(gameAnswerPayloadSchema).returns(z.void()),
  request_participants: z
    .function()
    .args(
      z.object({
        accessCode: z.string().min(1),
      }),
    )
    .returns(z.void()),
  teacher_set_question: z
    .function()
    .args(
      z.object({
        accessCode: z.string().min(1),
        questionUid: z.string().min(1),
        questionIndex: z.number().int().nonnegative(),
      }),
    )
    .returns(z.void()),
  teacher_timer_action: z
    .function()
    .args(
      z.object({
        accessCode: z.string().min(1),
        action: z.enum([
          'start',
          'pause',
          'resume',
          'stop',
          'set_duration',
        ]),
        duration: z.number().int().positive().optional(),
      }),
    )
    .returns(z.void()),
  teacher_lock_answers: z
    .function()
    .args(
      z.object({
        accessCode: z.string().min(1),
        lock: z.boolean(),
      }),
    )
    .returns(z.void()),
  teacher_end_game: z
    .function()
    .args(
      z.object({
        accessCode: z.string().min(1),
      }),
    )
    .returns(z.void()),
});

export const interServerEventsSchema = z.object({});

export const socketDataSchema = z.object({
  userId: z.string().min(1).optional(),
  username: z.string().min(1).optional(),
  role: z.enum(['player', 'teacher', 'admin', 'projector']).optional(),
  accessCode: z.string().min(1).optional(),
  currentGameRoom: z.string().min(1).optional(),
});

export const gameJoinedPayloadSchema = z.object({
  accessCode: z.string().min(1, { message: "Access code cannot be empty." }),
  participant: participantDataSchema,
  gameStatus: z.enum(['pending', 'active', 'completed', 'archived']),
  isDiffered: z.boolean(),
  differedAvailableFrom: z.string().datetime({ message: "Invalid datetime string for differedAvailableFrom. Must be an ISO string." }).optional(),
  differedAvailableTo: z.string().datetime({ message: "Invalid datetime string for differedAvailableTo. Must be an ISO string." }).optional(),
});

export const serverToClientEventsSchema = z.object({
  connect: z.function().args().returns(z.void()),
  disconnect: z.function().args(z.string()).returns(z.void()),
  connection_established: z
    .function()
    .args(
      z.object({
        socketId: z.string().min(1),
        timestamp: z.string().datetime(),
        user: socketDataSchema.partial(),
      }),
    )
    .returns(z.void()),
  game_joined: z.function().args(gameJoinedPayloadSchema).returns(z.void()),
  game_question: z.function().args(questionDataSchema).returns(z.void()),
  answer_received: z
    .function()
    .args(
      z.object({
        questionId: z.string().min(1),
        timeSpent: z.number().int().nonnegative(),
      }),
    )
    .returns(z.void()),
  leaderboard_update: z
    .function()
    .args(
      z.object({
        leaderboard: z.array(leaderboardEntryDataSchema),
      }),
    )
    .returns(z.void()),
  player_joined_game: z
    .function()
    .args(playerJoinedGamePayloadSchema)
    .returns(z.void()),
  player_left_game: z
    .function()
    .args(
      z.object({
        userId: z.string().min(1),
        socketId: z.string().min(1),
      }),
    )
    .returns(z.void()),
  game_participants: z
    .function()
    .args(
      z.object({
        participants: z.array(participantDataSchema),
      }),
    )
    .returns(z.void()),
  game_state_update: z.function().args(z.any()).returns(z.void()),
  timer_update: z
    .function()
    .args(
      z.object({
        timeLeft: z.number().int().nonnegative().nullable(),
        running: z.boolean(),
        duration: z.number().int().positive().optional(),
      }),
    )
    .returns(z.void()),
  answers_locked: z
    .function()
    .args(
      z.object({
        locked: z.boolean(),
      }),
    )
    .returns(z.void()),
  game_ended: z
    .function()
    .args(
      z.object({
        accessCode: z.string().min(1),
      }),
    )
    .returns(z.void()),
  game_error: z.function().args(errorPayloadSchema).returns(z.void()),
  game_already_played: z
    .function()
    .args(gameAlreadyPlayedPayloadSchema)
    .returns(z.void()),
  notification: z.function().args(notificationPayloadSchema).returns(z.void()),
  game_control_question_set: z
    .function()
    .args(
      z.object({
        questionIndex: z.number().int().nonnegative(),
        timer: z.object({
          startedAt: z.number(),
          duration: z.number(),
          isPaused: z.boolean(),
          pausedAt: z.number().optional(),
          timeRemaining: z.number().optional()
        })
      })
    )
    .returns(z.void()),
  game_control_question_ended: z
    .function()
    .args(
      z.object({
        questionUid: z.string(),
        timer: z.object({
          startedAt: z.number(),
          duration: z.number(),
          isPaused: z.boolean(),
          pausedAt: z.number().optional(),
          timeRemaining: z.number().optional()
        })
      })
    )
    .returns(z.void()),
  question_ended: z
    .function()
    .args(
      z.object({
        questionUid: z.string(),
        showLeaderboard: z.boolean().optional(),
        leaderboard: z.array(
          z.object({
            userId: z.string(),
            username: z.string(),
            avatarEmoji: z.string().optional(),
            score: z.number()
          })
        ).optional()
      })
    )
    .returns(z.void())
});
