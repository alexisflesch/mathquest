// Generated by ts-to-zod
import { z } from 'zod';

// Teacher dashboard payload schemas
export const setQuestionPayloadSchema = z.object({
  accessCode: z.string().min(1, { message: "Access code cannot be empty." }),
  questionUid: z.string().min(1, { message: "Question UID cannot be empty." }),
  questionIndex: z.number().int().nonnegative({ message: "Question index must be non-negative." }).optional(),
});

export const joinDashboardPayloadSchema = z.object({
  accessCode: z.string().min(1, { message: "Access code cannot be empty." }),
});

export const timerActionPayloadSchema = z.object({
  accessCode: z.string().min(1, { message: "Access code cannot be empty." }),
  action: z.enum(['start', 'pause', 'resume', 'stop', 'set_duration'], {
    errorMap: () => ({ message: "Action must be one of: start, pause, resume, stop, set_duration" }),
  }),
  duration: z.number().int().nonnegative({ message: "Duration must be a non-negative integer." }).optional(),
  questionUid: z.string().min(1, { message: "Question UID cannot be empty." }).optional(),
});

export const lockAnswersPayloadSchema = z.object({
  accessCode: z.string().min(1, { message: "Access code cannot be empty." }),
  lock: z.boolean({ errorMap: () => ({ message: "Lock must be a boolean value." }) }),
});

export const endGamePayloadSchema = z.object({
  accessCode: z.string().min(1, { message: "Access code cannot be empty." }),
});

export const joinGamePayloadSchema = z.object({
  accessCode: z.string().min(1, { message: "Access code cannot be empty." }),
  userId: z.string().min(1, { message: "Player ID cannot be empty." }),
  username: z.string().min(1, { message: "Username cannot be empty." }),
  avatarEmoji: z.string().optional(),
  isDiffered: z.boolean().optional(),
});

export const gameAnswerPayloadSchema = z.object({
  accessCode: z.string().min(1, { message: "Access code cannot be empty." }),
  userId: z.string().min(1, { message: "Player ID cannot be empty." }),
  questionUid: z.string().min(1, { message: "Question UID cannot be empty." }),
  answer: z.union([
    z.string(),
    z.number(),
    z.array(z.string()),
    z.array(z.number())
  ]),
  timeSpent: z.number().int({ message: "Time spent must be an integer." }).nonnegative({ message: "Time spent cannot be negative." }),
});

export const errorPayloadSchema = z.object({
  message: z.string().min(1, { message: "Error message cannot be empty." }),
  code: z.union([z.string(), z.number()]).optional(),
  details: z.record(z.any()).optional(),
});

export const gameAlreadyPlayedPayloadSchema = z.object({
  accessCode: z.string().min(1, { message: "Access code cannot be empty." }),
});

export const participantDataSchema = z.object({
  id: z.string().min(1, { message: "Participant ID cannot be empty." }),
  userId: z.string().min(1, { message: "Player ID cannot be empty." }),
  username: z.string().min(1, { message: "Username cannot be empty." }),
  avatarEmoji: z.string().min(1, { message: "Avatar emoji cannot be empty." }),
  score: z.number().int({ message: "Score must be an integer." }),
  online: z.boolean().optional(),
  joinedAt: z.union([z.string().datetime({ message: "Invalid datetime string for joinedAt" }), z.number()]).optional(),
  socketId: z.string().optional(),
  isDeferred: z.boolean().optional(),
  cookieId: z.string().optional(),
});

export const playerJoinedGamePayloadSchema = z.object({
  participant: participantDataSchema,
});

export const notificationPayloadSchema = z.object({
  message: z.string().min(1, { message: "Notification message cannot be empty." }),
  defaultMode: z.enum(['info', 'warning', 'error', 'success']),
});

export const questionDataSchema = z.object({
  uid: z.string().min(1, { message: "Question UID cannot be empty." }),
  title: z.string().min(1).optional(),
  text: z.string().min(1, { message: "Question text cannot be empty." }),
  answerOptions: z.array(z.string().min(1)).min(1, { message: "A question must have at least one answer option." }),
  correctAnswers: z.array(z.boolean()), // Now required everywhere
  questionType: z.string().min(1, { message: "Question type cannot be empty." }),
  timeLimit: z.number().int({ message: "Time limit must be an integer." }).positive({ message: "Time limit must be positive." }).optional(),
  currentQuestionIndex: z.number().int({ message: "Question index must be an integer." }).nonnegative({ message: "Question index cannot be negative." }).optional(),
  totalQuestions: z.number().int({ message: "Total questions must be an integer." }).positive({ message: "Total questions must be positive." }).optional(),
});

export const leaderboardEntryDataSchema = z.object({
  userId: z.string().min(1, { message: "Player ID cannot be empty." }),
  username: z.string().min(1, { message: "Username cannot be empty." }),
  avatarEmoji: z.string().optional(),
  score: z.number().int({ message: "Score must be an integer." }),
  rank: z.number().int({ message: "Rank must be an integer." }).positive({ message: "Rank must be positive." }).optional(),
});

export const clientToServerEventsSchema = z.object({
  join_game: z.function().args(joinGamePayloadSchema).returns(z.void()),
  game_answer: z.function().args(gameAnswerPayloadSchema).returns(z.void()),
  request_participants: z
    .function()
    .args(
      z.object({
        accessCode: z.string().min(1),
      }),
    )
    .returns(z.void()),
  teacher_set_question: z
    .function()
    .args(
      z.object({
        accessCode: z.string().min(1),
        questionUid: z.string().min(1),
        questionIndex: z.number().int().nonnegative(),
      }),
    )
    .returns(z.void()),
  teacher_timer_action: z
    .function()
    .args(
      z.object({
        accessCode: z.string().min(1),
        action: z.enum([
          'start',
          'pause',
          'resume',
          'stop',
          'set_duration',
        ]),
        duration: z.number().int().positive().optional(),
      }),
    )
    .returns(z.void()),
  teacher_lock_answers: z
    .function()
    .args(
      z.object({
        accessCode: z.string().min(1),
        lock: z.boolean(),
      }),
    )
    .returns(z.void()),
  teacher_end_game: z
    .function()
    .args(
      z.object({
        accessCode: z.string().min(1),
      }),
    )
    .returns(z.void()),
});

export const interServerEventsSchema = z.object({});

export const socketDataSchema = z.object({
  userId: z.string().min(1).optional(),
  username: z.string().min(1).optional(),
  role: z.enum(['player', 'teacher', 'admin', 'projector']).optional(),
  accessCode: z.string().min(1).optional(),
  currentGameRoom: z.string().min(1).optional(),
});

export const gameJoinedPayloadSchema = z.object({
  accessCode: z.string().min(1, { message: "Access code cannot be empty." }),
  participant: participantDataSchema,
  gameStatus: z.enum(['pending', 'active', 'completed', 'archived']),
  isDiffered: z.boolean(),
  differedAvailableFrom: z.string().datetime({ message: "Invalid datetime string for differedAvailableFrom. Must be an ISO string." }).optional(),
  differedAvailableTo: z.string().datetime({ message: "Invalid datetime string for differedAvailableTo. Must be an ISO string." }).optional(),
});

export const requestNextQuestionPayloadSchema = z.object({
  accessCode: z.string().min(1, { message: "Access code cannot be empty." }),
  userId: z.string().min(1, { message: "User ID cannot be empty." }),
  currentQuestionUid: z.string().min(1, { message: "Current question UID cannot be empty." }),
});

// Canonical event payload schemas (for tournament-style events)
export const correctAnswersPayloadSchema = z.object({
  questionUid: z.string().min(1, { message: "Question UID cannot be empty." }),
  correctAnswers: z.array(z.boolean()).optional(),
});

export const feedbackPayloadSchema = z.object({
  questionUid: z.string().min(1, { message: "Question UID cannot be empty." }),
  feedbackRemaining: z.number().int().nonnegative({ message: "Feedback remaining must be non-negative." }),
}).catchall(z.any()); // Allow additional properties for flexibility

// Game state update payload schema
export const gameStateUpdatePayloadSchema = z.object({
  status: z.enum(['waiting', 'active', 'paused', 'finished']).optional(),
  currentQuestion: questionDataSchema.optional(),
  questionIndex: z.number().int().nonnegative().optional(),
  totalQuestions: z.number().int().positive().optional(),
  timer: z.number().int().nonnegative().optional(),
  participants: z.array(participantDataSchema).optional(),
}).catchall(z.any()); // Allow additional properties for flexibility

// Answer received payload schema
export const answerReceivedPayloadSchema = z.object({
  questionUid: z.string().min(1, { message: "Question UID cannot be empty." }),
  timeSpent: z.number().int().nonnegative({ message: "Time spent must be a non-negative integer." }),
  correct: z.boolean().optional(),
  correctAnswers: z.array(z.boolean()).optional(),
  explanation: z.string().optional(),
});

// Answer feedback payload schema
export const answerFeedbackPayloadSchema = z.object({
  status: z.enum(['ok', 'error'], { message: "Status must be 'ok' or 'error'." }),
  questionUid: z.string().min(1, { message: "Question UID cannot be empty." }).optional(),
  scoreAwarded: z.number().int().nonnegative({ message: "Score awarded must be a non-negative integer." }).optional(),
  code: z.string().optional(),
  message: z.string().optional(),
  isCorrect: z.boolean().optional(),
  correctAnswers: z.array(z.boolean()).optional(),
  explanation: z.string().optional(),
}).catchall(z.any()); // Allow additional properties for flexibility

export const serverToClientEventsSchema = z.object({
  connect: z.function().args().returns(z.void()),
  disconnect: z.function().args(z.string()).returns(z.void()),
  connection_established: z
    .function()
    .args(
      z.object({
        socketId: z.string().min(1),
        timestamp: z.string().datetime(),
        user: socketDataSchema.partial(),
      }),
    )
    .returns(z.void()),
  game_joined: z.function().args(gameJoinedPayloadSchema).returns(z.void()),
  game_question: z.function().args(questionDataSchema).returns(z.void()),
  answer_received: z.function().args(answerReceivedPayloadSchema).returns(z.void()),
  leaderboard_update: z
    .function()
    .args(
      z.object({
        leaderboard: z.array(leaderboardEntryDataSchema),
      }),
    )
    .returns(z.void()),
  player_joined_game: z
    .function()
    .args(playerJoinedGamePayloadSchema)
    .returns(z.void()),
  player_left_game: z
    .function()
    .args(
      z.object({
        userId: z.string().min(1),
        socketId: z.string().min(1),
      }),
    )
    .returns(z.void()),
  game_participants: z
    .function()
    .args(
      z.object({
        participants: z.array(participantDataSchema),
      }),
    )
    .returns(z.void()),
  game_state_update: z.function().args(gameStateUpdatePayloadSchema).returns(z.void()),
  timer_update: z
    .function()
    .args(
      z.object({
        timeLeftMs: z.number().int().nonnegative().nullable(),
        running: z.boolean(),
        durationMs: z.number().int().positive().optional(),
      }),
    )
    .returns(z.void()),
  answers_locked: z
    .function()
    .args(
      z.object({
        locked: z.boolean(),
      }),
    )
    .returns(z.void()),
  game_ended: z
    .function()
    .args(
      z.object({
        accessCode: z.string().min(1),
      }),
    )
    .returns(z.void()),
  game_error: z.function().args(errorPayloadSchema).returns(z.void()),
  game_already_played: z
    .function()
    .args(gameAlreadyPlayedPayloadSchema)
    .returns(z.void()),
  notification: z.function().args(notificationPayloadSchema).returns(z.void()),
  game_control_question_set: z
    .function()
    .args(
      z.object({
        questionIndex: z.number().int().nonnegative(),
        timer: z.object({
          startedAt: z.number(),
          duration: z.number(),
          isPaused: z.boolean(),
          pausedAt: z.number().optional(),
          timeRemaining: z.number().optional()
        })
      })
    )
    .returns(z.void()),
  game_control_question_ended: z
    .function()
    .args(
      z.object({
        questionUid: z.string(),
        timer: z.object({
          startedAt: z.number(),
          duration: z.number(),
          isPaused: z.boolean(),
          pausedAt: z.number().optional(),
          timeRemaining: z.number().optional()
        })
      })
    )
    .returns(z.void()),
  question_ended: z
    .function()
    .args(
      z.object({
        questionUid: z.string(),
        showLeaderboard: z.boolean().optional(),
        leaderboard: z.array(
          z.object({
            userId: z.string(),
            username: z.string(),
            avatarEmoji: z.string().optional(),
            score: z.number()
          })
        ).optional()
      })
    )
    .returns(z.void()),
  // Teacher dashboard socket event schemas
  set_question: z.function().args(setQuestionPayloadSchema).returns(z.void()),
  join_dashboard: z.function().args(joinDashboardPayloadSchema).returns(z.void()),
  timer_action: z.function().args(timerActionPayloadSchema).returns(z.void()),
  lock_answers: z.function().args(lockAnswersPayloadSchema).returns(z.void()),
  end_game: z.function().args(endGamePayloadSchema).returns(z.void()),
  // Canonical tournament/practice events
  correct_answers: z.function().args(correctAnswersPayloadSchema).returns(z.void()),
  feedback: z.function().args(feedbackPayloadSchema).returns(z.void()),
});

// Additional teacher control schemas
export const startTimerPayloadSchema = z.object({
  gameId: z.string().min(1, { message: "Game ID cannot be empty." }).optional(),
  accessCode: z.string().min(1, { message: "Access code cannot be empty." }).optional(),
  duration: z.number().int().positive({ message: "Duration must be a positive integer." }),
}).refine(data => data.gameId || data.accessCode, {
  message: "Either gameId or accessCode must be provided.",
});

export const pauseTimerPayloadSchema = z.object({
  gameId: z.string().min(1, { message: "Game ID cannot be empty." }).optional(),
  accessCode: z.string().min(1, { message: "Access code cannot be empty." }).optional(),
}).refine(data => data.gameId || data.accessCode, {
  message: "Either gameId or accessCode must be provided.",
});

// Tournament schemas
export const startTournamentPayloadSchema = z.object({
  accessCode: z.string().min(1, { message: "Access code cannot be empty." }),
});

// Projector schemas
export const joinProjectorPayloadSchema = z.object({
  gameId: z.string().min(1, { message: "Game ID cannot be empty." }),
});

export const leaveProjectorPayloadSchema = z.object({
  gameId: z.string().min(1, { message: "Game ID cannot be empty." }),
});

// Lobby schemas
export const joinLobbyPayloadSchema = z.object({
  accessCode: z.string().min(1, { message: "Access code cannot be empty." }),
  userId: z.string().min(1, { message: "User ID cannot be empty." }),
  username: z.string().min(1, { message: "Username cannot be empty." }),
  avatarEmoji: z.string().optional(),
});

export const leaveLobbyPayloadSchema = z.object({
  accessCode: z.string().min(1, { message: "Access code cannot be empty." }),
  userId: z.string().min(1, { message: "User ID cannot be empty." }).optional(),
});

export const getParticipantsPayloadSchema = z.object({
  accessCode: z.string().min(1, { message: "Access code cannot be empty." }),
});

// Game start schema
export const startGamePayloadSchema = z.object({
  accessCode: z.string().min(1, { message: "Access code cannot be empty." }),
  userId: z.string().min(1, { message: "User ID cannot be empty." }),
});

export const requestParticipantsPayloadSchema = z.object({
  accessCode: z.string().min(1, { message: "Access code cannot be empty." }),
});

// Shared live handler schemas
export const sharedJoinPayloadSchema = z.object({
  accessCode: z.string().min(1, { message: "Access code cannot be empty." }),
  userId: z.string().min(1, { message: "User ID cannot be empty." }),
  username: z.string().min(1, { message: "Username cannot be empty." }),
  avatarEmoji: z.string().optional(),
  playMode: z.enum(['quiz', 'tournament', 'practice']).optional(),
});

export const sharedAnswerPayloadSchema = z.object({
  accessCode: z.string().min(1, { message: "Access code cannot be empty." }),
  userId: z.string().min(1, { message: "User ID cannot be empty." }),
  questionUid: z.string().min(1, { message: "Question UID cannot be empty." }),
  answer: z.union([
    z.string(),
    z.number(),
    z.array(z.string()),
    z.array(z.number())
  ]),
  timeSpent: z.number().int({ message: "Time spent must be an integer." }).nonnegative({ message: "Time spent cannot be negative." }),
  playMode: z.enum(['quiz', 'tournament', 'practice']).optional(),
});

// Dashboard payload schemas
export const connectedCountPayloadSchema = z.object({
  count: z.number().int().nonnegative({ message: "Count must be a non-negative integer." }),
});

// Test-specific schemas for unit tests
export const joinRoomPayloadSchema = z.object({
  roomName: z.string().min(1, { message: "Room name cannot be empty." }),
});

export const testConnectionPayloadSchema = z.object({
  // No payload for connection event, but we can validate the socket metadata
});

// Game ended payload schema
export const gameEndedPayloadSchema = z.object({
  accessCode: z.string().min(1, { message: "Access code cannot be empty." }),
  endedAt: z.string().datetime({ message: "Invalid datetime string for endedAt. Must be an ISO string." }).optional(),
  score: z.number().int().nonnegative({ message: "Score must be a non-negative integer." }).optional(),
  totalQuestions: z.number().int().nonnegative({ message: "Total questions must be a non-negative integer." }).optional(),
  correct: z.number().int().nonnegative({ message: "Correct answers count must be a non-negative integer." }).optional(),
  total: z.number().int().nonnegative({ message: "Total answers count must be a non-negative integer." }).optional(),
});

// Connection established payload schema
export const connectionEstablishedPayloadSchema = z.object({
  socketId: z.string().min(1, { message: "Socket ID cannot be empty." }),
  timestamp: z.string().datetime({ message: "Invalid datetime string for timestamp. Must be an ISO string." }),
  user: z.object({
    userId: z.string().optional(),
    username: z.string().optional(),
    role: z.enum(['player', 'teacher', 'admin', 'projector']).optional(),
    accessCode: z.string().optional(),
    currentGameRoom: z.string().optional(),
    practiceSessionId: z.string().optional(),
    practiceUserId: z.string().optional(),
  }).partial(),
});

// Timer update payload schema
export const timerUpdatePayloadSchema = z.object({
  timeLeftMs: z.number().int().nonnegative().nullable(),
  running: z.boolean(),
  durationMs: z.number().int().positive().optional(),
});
